<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>100000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 초기 스타팅 포인트 작동 및 게임 진행에 필요 변수 선언입니다.
with (Obj_Starting_Point)
{
    alarm[0] = 1;
}

global.id_count = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 유닛 제어권 전역 변수 선언입니다.

var _socket = global.socket_num;
if (global.have_server == true)
{
    _socket = global.tcp_server;
}
for(var _i = 0; _i &lt; global.max_player; _i ++)
{
    if (global.get_player[_i] == _socket)
    {
        global.set_player = _i;
        global.set_team = _i;
        global.set_brood = _i;
        global.set_colour = _i;
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 시야 시스템에 사용될 변수를 선언합니다.
fog_sprite = sprite_duplicate(Spr_Fog); // 시야 스프라이트.
var _fog_mask_sprite = sprite_duplicate(Spr_Fog_Mask); // 시야 스프라이트에 적용할 마스크.
sprite_set_alpha_from_sprite(fog_sprite, _fog_mask_sprite); // 시야 스프라이트에 마스크 설정.
sprite_delete(_fog_mask_sprite); // 사용한 마스크 이미지는 삭제.

fog_scale = 64; // 안개 디테일. (작을 수록 많고, 높을 수록 작다.)
fog_quality = 2; // 안개 크기.

// 룸을 안개 갯수만큼 나눠, 평균 값을 구해냅니다.
fog_room_width = ceil(room_width / fog_scale); // 룸 넓이, 나눕니다.
fog_room_height = ceil((room_height) / fog_scale); // 룸 높이, 나눕니다.

// 화면을 안개 갯수만큼 나눠, 평균 값을 구해냅니다.
fog_view_width = ceil(view_wview[0] / fog_scale); // 화면 넓이, 나눕니다.
fog_view_height = ceil(view_hview[0] / fog_scale); // 화면 높이, 나눕니다.

// 그리드 선언.
fog_grid = ds_grid_create(fog_room_width + 1, fog_room_height + 1);
ds_grid_clear(fog_grid, 1); // 모든 기본 값은 1으로.
//fog_alpha = ds_grid_create(fog_room_width + 1, fog_room_height + 1);
//ds_grid_clear(fog_alpha, 1); // 모든 기본 값은 1으로.

// 실행 주기.
fog_step_alarm_max = ceil(room_speed / 15);
fog_step_alarm = fog_step_alarm_max;

// 서피스 선언.
fog_surface = surface_create(room_width, room_height); // 화면 크기의 서피스를 생성합니다.
surface_set_target(fog_surface);
draw_clear(0); // 서피스 화면을 검은색으로 채웁니다.
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 타일을 사용하기 위해 사용될 변수입니다.
tile_surface = -1;

// 타일 디폴트 값 생성.
for (var _i = fog_room_width; _i &gt;= 0; _i --)
{
    for (var _k = fog_room_height; _k &gt;= 0; _k --)
    {
        tile_table[_i, _k] = 0;
        tile_table_u_l[_i, _k] = 0;
        tile_table_u_r[_i, _k] = 0;
        tile_table_b_l[_i, _k] = 0;
        tile_table_b_r[_i, _k] = 0;
    }
}

// 오브젝트 배치식 타일 스무스화.
for (var _i = fog_room_width; _i &gt;= 0; _i --)
{
    for (var _k = fog_room_height; _k &gt;= 0; _k --)
    { 
        var _x = _i * fog_scale;
        var _y = _k * fog_scale;
        var _place = instance_position(_x, _y, all);
        if (instance_exists(_place) == true)
        {
            switch(_place.object_index)
            {
                case Obj_Tile_Water: 
                tile_table[_i, _k] = 20;
                break;
                
                case Obj_Tile_Mount: 
                tile_table[_i, _k] = 30;
                break;
            }
        }
    }
}

// 1차 타일 스무스화.
for(var _i = 0; _i &lt; fog_room_width; _i ++)
{
    for(var _k = 0; _k &lt; fog_room_height; _k ++)
    {
    for(var _m = _i - 1; _m &lt;= _i + 1; _m ++)
       {
           for(var _n = _k - 1; _n &lt;= _k + 1; _n ++)
           {
               if (_m &lt; 0) || (_n &lt; 0) || (_m &gt;= fog_room_width) || (_n &gt;= fog_room_height)
               || ((_i == _m) &amp;&amp; (_k == _n))
               {continue;}

               var _left = false, _right = false, _up = false, _down = false;
               if (_m == _i - 1) {_left = true;}
               if (_m == _i + 1) {_right = true;}
               if (_n == _k - 1) {_up = true;}
               if (_n == _k + 1) {_down = true;}
               
               if (tile_table[_i, _k] == 20)
               &amp;&amp; (tile_table[_m, _n] == 0)
               {
                   if (_left == true)
                   {
                       if (_up == true)
                       {tile_table_u_l[_i, _k] ++;}
                       else if (_down == true)
                       {tile_table_b_l[_i, _k] ++;}
                       else
                       {
                           tile_table_u_l[_i, _k] ++;
                           tile_table_b_l[_i, _k] ++;
                       }
                   }
                   else if (_right == true)
                   {
                       if (_up == true)
                       {tile_table_u_r[_i, _k] ++;}
                       else if (_down == true)
                       {tile_table_b_r[_i, _k] ++;}
                       else
                       {
                           tile_table_u_r[_i, _k] ++;
                           tile_table_b_r[_i, _k] ++;
                       }
                   }
                   if (_up == true)
                   {
                       if (_left == true)
                       {tile_table_u_l[_i, _k] ++;}
                       else if (_right == true)
                       {tile_table_u_r[_i, _k] ++;}
                       else
                       {
                           tile_table_u_l[_i, _k] ++;
                           tile_table_u_r[_i, _k] ++;
                       }
                   }
                   else if (_down == true)
                   {
                       if (_left == true)
                       {tile_table_b_l[_i, _k] ++;}
                       else if (_right == true)
                       {tile_table_b_r[_i, _k] ++;}
                       else
                       {
                           tile_table_b_l[_i, _k] ++;
                           tile_table_b_r[_i, _k] ++;
                       }
                   }
               }
           }
       }
    }
}

// 2차 타일 스무스 드로우.
for(var _i = 0; _i &lt; fog_room_width; _i ++)
{
    for(var _k = 0; _k &lt; fog_room_height; _k ++)
    {
        var _u_left = false, _u_right = false, _b_left = false, _b_right = false;
        if (tile_table_u_l[_i, _k] &gt; 0) {_u_left = true;}
        if (tile_table_u_r[_i, _k] &gt; 0) {_u_right = true;}
        if (tile_table_b_l[_i, _k] &gt; 0) {_b_left = true;}
        if (tile_table_b_r[_i, _k] &gt; 0) {_b_right = true;}
        
        // 시작.
        if (_u_left == true) &amp;&amp; (_b_left == true) &amp;&amp; (_u_right == true)
        {
            tile_table[_i, _k] = 5;
        }
        else if (_u_left == true) &amp;&amp; (_b_left == true) &amp;&amp; (_b_right == true)
        {
            tile_table[_i, _k] = 6;
        }
        else if (_u_right == true) &amp;&amp; (_b_right == true) &amp;&amp; (_u_left == true)
        {
            tile_table[_i, _k] = 7;
        }
        else if (_u_right == true) &amp;&amp; (_b_right == true) &amp;&amp; (_b_left == true)
        {
            tile_table[_i, _k] = 8;
        }
        else if (_u_left == true) &amp;&amp; (_b_left == true)
        {
            tile_table[_i, _k] = 1;
        }
        else if (_u_right == true) &amp;&amp; (_b_right == true)
        {
            tile_table[_i, _k] = 2;
        }
        else if (_u_left == true) &amp;&amp; (_u_right == true)
        {
            tile_table[_i, _k] = 3;
        }
        else if (_b_left == true) &amp;&amp; (_b_right == true)
        {
            tile_table[_i, _k] = 4;
        }
        else if (_u_left == true)
        {
            tile_table[_i, _k] = 9;
        }
        else if (_b_left == true)
        {
            tile_table[_i, _k] = 10;
        }
        else if (_u_right == true)
        {
            tile_table[_i, _k] = 11;
        }
        else if (_b_right == true)
        {
            tile_table[_i, _k] = 12;
        }
    }
}

// 3차 타일 단조로움 해결.
for (var _i = fog_room_width; _i &gt;= 0; _i --)
{
    for (var _k = fog_room_height; _k &gt;= 0; _k --)
    {
        if (tile_table[_i, _k] == 0)
        {
            tile_table[_i, _k] = choose(0, 13);
        }
        else if (tile_table[_i, _k] == 20)
        {
            tile_table[_i, _k] = choose(20, 21);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 미니맵 시스템 사용을 위한 변수 선언입니다.
instance_deactivate_all(true);
instance_activate_object(Obj_Block); // 백그라운드에 표시할 오브젝트.
instance_activate_object(Obj_Floor);

// 미니맵 백그라운드 설정입니다.
mini_fog_draw = false; // 미니맵 백그라운드 드로우를 위해 초기 실행 판단 변수.
mini_fog_sprite = noone;
mini_fog_sprite_width = 0;
mini_fog_sprite_height = 0;
mini_fog_sprite_x_scale = 0;
mini_fog_sprite_y_scale = 0;
mini_fog_width = 280; // 가로 사이즈.
mini_fog_height = 280; // 세로 사이즈.

// 미니맵 좌표로 설정될 변수입니다.
mini_fog_x = 4;
mini_fog_y = view_hview[0] - (mini_fog_height + 4);
mini_fog_x_scale = (mini_fog_width / room_width);
mini_fog_y_scale = (mini_fog_height / room_height);
mini_fog_x_scale_sight = (fog_scale / room_width);
mini_fog_y_scale_sight = (fog_scale / room_height);

// 실행 주기.
mini_fog_alarm_max = ceil(room_speed / 0.5);
mini_fog_alarm = mini_fog_alarm_max;
mini_fog_colour_alarm_max = ceil(room_speed / 1);
mini_fog_colour_alarm = mini_fog_colour_alarm_max;

// 서피스 선언.
mini_fog_surface = surface_create(mini_fog_width, mini_fog_height);
mini_fog_colour_surface = surface_create(mini_fog_width, mini_fog_height);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 화면 스크롤 및 확대 축소 기능입니다.
zoom_x_in = display_get_gui_width() / 2;
zoom_x_out = display_get_gui_width();
zoom_y_in = display_get_gui_height() / 2;
zoom_y_out = display_get_gui_height();

// 화면 확대, 축소 기능.
screen_zoom_height = 200;
screen_zoom_x = 32;
screen_zoom_y = mini_fog_y - (screen_zoom_height + 64);
screen_zoom_bar_x = screen_zoom_x;
screen_zoom_bar_y = screen_zoom_y + (screen_zoom_height / 2);
screen_zoom_pressed = false;
screen_zoom_pressed_y = 0;

view_switch = false;
view_move_x = 0;
view_move_y = 0;

cont_dis = 0; // 화면 확대 및 축소. (0: 축소 ~ 1: 확대)
real_dis = 0; // 부드러운 이동 처리.
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// GUI 사용을 위한 변수 선언입니다.

// GUI 알파 값.
gui_alpha_min = 0.4;
gui_alpha_max = 1;
gui_alpha_speed = 0.02 * (global.target_fps / room_speed);
gui_alpha = gui_alpha_max;
gui_switch = false;

// 유닛 상세 정보 GUI.
info_switch = true;

// 건물 관련해서 필요한 변수를 선언합니다.
build_id = noone; // 건설할 인물.
build_target = noone; // 건설할 건물.
build_x = -1; // 건설할 좌표.
build_y = -1; // 건설할 좌표.
build_resource[2] = -1; // 소모되는 인구.
build_resource[1] = -1; // 소모되는 오일.
build_resource[0] = -1; // 소모되는 광석.
build_index = -1; // ACTION 실행할 변수.
build_grid = 64; // 건물 건설 그리드 간격.

// 부대 지정에 필요한 변수를 선언합니다.
group_max = 4;
group_check = false; // 눌렸는지 안눌렸는지 확인.
group_width = 80;
group_height = 80;
group_x = display_get_gui_width() - (group_width + 4);
group_y = 88;
group_length = 4;
group_height_max = group_y + ((group_length + group_height) * group_max);
for(var _i = (group_max - 1); _i &gt;= 0; _i --)
{
    group_list[_i] = ds_list_create();
    group_pressed[_i] = false; // GUI가 눌렸는지 확인.
    group_pressed_y[_i] = 0; // 누른 시점에서의 Y 좌표.
    group_pressed_y_check[_i] = false; // 발동했는지 확인하여 중복 발동 안되게 설정.
    group_pressed_y_anim_switch[_i] = 0; // 애니메이션 표시. (1: 위, 2: 아래)
    group_pressed_y_anim_fade[_i] = 0; // 애니메이션 진행.
    group_pressed_y_lenth[_i] = 32; // 얼마나 이동해야 발동하는지 설정.
    group_double_tab_time[_i] = 0;
    group_double_tab_time_max[_i] = (0.2 * room_speed);
    group_camera[_i] = false;
}
anim_fade_speed = 0.04 * (global.target_fps / room_speed); // 애니메이션 속도.

// 명령창 GUI.
for(var _i = 0; _i &lt; 8; _i ++)
{
    box_pressed[_i] = false;
    box_double_tab_time[_i] = 0;
    box_double_tab_time_max[_i] = (0.2 * room_speed);
    box_pressed_anim_fade[_i] = 0;
}
command_gui_width = 96;
command_gui_height = 96;
command_gui_x = (display_get_gui_width() - 400) - 4; // 명령창 X 좌표.
command_gui_y = (display_get_gui_height() - 204) - 4; // 명령창 Y 좌표.
command_gui_x_width = (display_get_gui_width() - 4); // 명령창 끝의 X 좌표.
command_gui_y_height = display_get_gui_height() - 4; // 명령창 끝의 Y 좌표.

// 주요 알림 텍스트 GUI.
command_string_switch = false;
command_string = "";
command_string_time_max = (room_speed * 3);
command_string_time = command_string_time_max;
command_string_alpha = 0;

command_string_list[0] = "광석을 더 채집하십시오.";
command_string_list[1] = "기름을 더 채집하십시오.";
command_string_list[2] = "보급이 더 필요합니다.";
command_string_list[3] = "해당 위치에 건설할 수 없습니다.";
command_string_list[4] = "";

// 쉐이더 시스템.
colour_to_find = shader_get_uniform(shader_set_colour, "f_Colour1");
colour_to_set = shader_get_uniform(shader_set_colour, "f_Colour2");
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 마우스 관련 변수 선언입니다.
for(var _i = 1; _i &gt;= 0; _i --;) // (0, 1)
{
    mbc_L[_i] = device_mouse_check_button(_i, mb_left);
    mbp_L[_i] = device_mouse_check_button_pressed(_i, mb_left);
    mbr_L[_i] = device_mouse_check_button_released(_i, mb_left);
    mx[_i] = device_mouse_x(_i);
    my[_i] = device_mouse_y(_i);
    mx_gui[_i] = device_mouse_x_to_gui(_i);
    my_gui[_i] = device_mouse_y_to_gui(_i);
    
    click_push[_i] = false; // 누르고 있는지 확인. (지속 시간 온 / 오프).
    click_push_time[_i] = 0; // 지속 시간.
}
mbc_R = device_mouse_check_button(0, mb_right);
mbp_R = device_mouse_check_button_pressed(0, mb_right);
mbr_R = device_mouse_check_button_released(0, mb_right);

mouse_x_pre = 0; // 화면 이동 시 처음에 눌렀던 위치 변수.
mouse_y_pre = 0; // 화면 이동 시 처음에 눌렀던 위치 변수.
sc_x = 0; // 눌렀던 X 좌표.
sc_y = 0; // 눌렀던 Y 좌표.
sc_on = false; // 화면 상에서 눌렀는지 확인.

click_mbp = false; // 화면상에서 클릭헀는지 확인.
click_double = noone; // 두번 클릭 시스템 지원.
click_double_time = 0; // 두번 클릭시 시간 제한.
click_mini_map = false; // 미니맵을 클릭했는지 확인.
click_prev = noone; // 전에 눌렀던 인스턴스 담기.
select_drag = false; // 드래그를 했는지

select_list = ds_list_create(); // 건물 및 유닛 제어에 필요한 변수 선언입니다.
select_max = 28; // 선택하는 최대 건물 및 유닛 개수 지정.
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 사운드를 관리하는 변수를 선언합니다.
audio_bgm_stop_all();

audio_channel = ds_list_create();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 시스템 인스턴스 생성입니다.
instance_create(32, 0, Obj_Net_System);
instance_create(64, 0, Obj_Part_System);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 자료 구조 삭제.
ds_list_destroy(select_list);
ds_list_destroy(audio_channel);
ds_grid_destroy(fog_grid);

// 서피스 삭제.
surface_free(fog_surface);
surface_free(mini_fog_surface);
surface_free(mini_fog_colour_surface);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 스테레오 사운드를 조절합니다.
audio_listener_position(-(view_xview[0] + (view_wview[0])), view_yview[0] + (view_hview[0] / 2), 0);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 오디오 채널 관리.
var _size = ds_list_size(audio_channel);
var _max_size = 2;
for(var _i = 0; _i &lt; _size; _i ++)
{
    var _value = ds_list_find_value(audio_channel, _i);
    if (_value != undefined)
    {
        if (audio_is_playing(_value) == false)
        {
            ds_list_delete(audio_channel, 0);
        }
        if (_i &gt;= _max_size)
        {
            audio_stop_sound(_value);
            ds_list_delete(audio_channel, 0);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// GUI 투명도 조절, 화면 자동 이동 기능입니다.
if (view_yview[0] &gt;= room_height - view_hview[0])
&amp;&amp; (gui_alpha &gt; gui_alpha_min) {gui_alpha -= gui_alpha_speed;}
else if (gui_alpha &lt; gui_alpha_max) {gui_alpha += gui_alpha_speed;}

//show_debug_message(view_xview[0]);
//show_debug_message(view_yview[0]);

if (view_switch == true)
{
    if (view_xview[0] == view_move_x)
    &amp;&amp; (view_yview[0] == view_move_y)
    {
        view_switch = false;
    }
    else
    {
        var _speed = 20;
        var _move_x = ceil((view_xview[0] - view_move_x) / _speed);
        var _move_y = ceil((view_yview[0] - view_move_y) / _speed);
    
        view_xview[0] -= _move_x;
        view_yview[0] -= _move_y;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 마우스 관련 변수 선언입니다.
for(var _i = 0; _i &lt; 2; _i ++)
{
    mbc_L[_i] = device_mouse_check_button(_i, mb_left);
    mbp_L[_i] = device_mouse_check_button_pressed(_i, mb_left);
    mbr_L[_i] = device_mouse_check_button_released(_i, mb_left);
    mx[_i] = device_mouse_x(_i);
    my[_i] = device_mouse_y(_i);
    mx_gui[_i] = device_mouse_x_to_gui(_i);
    my_gui[_i] = device_mouse_y_to_gui(_i);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 건물 및 유닛 관련하여 마우스 제어 행동입니다.
if (global.draw_gui == true) &amp;&amp; (global.lock_step == false)
{
    if (build_id == noone) // 건물 건설 상태가 아닌 경우에만 실행합니다.
    {
        if ((mbc_L[0] == true) &amp;&amp; (mbc_L[1] == true) &amp;&amp; (sc_on == false) &amp;&amp; (group_check == false) &amp;&amp; (click_mini_map == false)) 
        {select_drag = true;}
        
        for(var _i = 0; _i &lt; 1; _i ++)
        {
            if ((mx_gui[_i] &lt; command_gui_x) || (my_gui[_i] &lt; command_gui_y)) // GUI 명령창을 벗어났을 때.
            &amp;&amp; ((mx_gui[_i] &gt; mini_fog_x + mini_fog_width) || (my_gui[_i] &lt; mini_fog_y)) // GUI 미니맵을 벗어났을 때.
            &amp;&amp; ((mx_gui[_i] &lt; group_x) || !((my_gui[_i] &gt; group_y) &amp;&amp; (my_gui[_i] &lt; group_height_max))) // GUI 부대창을 벗어났을 때.
            &amp;&amp; ((select_drag == false) &amp;&amp; (click_push[_i] == false) &amp;&amp; (sc_on == false) &amp;&amp; (group_check == false) &amp;&amp; (screen_zoom_pressed == false))
            {
                if (mbp_L[_i] == true) {click_mbp = true;}
                if (mbc_L[_i] == true) &amp;&amp; (click_mbp == true) // 마우스를 누르고 있을 때.
                {
                    if (click_push_time[_i] &gt;= (room_speed / 5))
                    {
                        while(true) // build가 0인 유닛은 제외.
                        {
                            var _obj = instance_position(mx[_i], my[_i], Obj_Sight);
                            if (instance_exists(_obj) == true) 
                            &amp;&amp; (ds_grid_get(fog_grid, _obj.f_x, _obj.f_y) == 0) 
                            {
                                if (_obj.build == 0) {instance_deactivate_object(_obj);}
                                else {instance_activate_all(); break;}
                            } else {_obj = noone; instance_activate_all(); break;}
                        }
                        
                        var _size = ds_list_size(select_list);
                        if (instance_exists(_obj) == true) 
                        {
                            for (var _j = 0; _j &lt; _size; _j ++)
                            {
                                var _ins = ds_list_find_value(select_list, _j);
                                if (instance_exists(_ins) == true)
                                &amp;&amp; (global.set_player == _ins.set_player)
                                &amp;&amp; (_ins.build != 0)
                                {
                                    var _action = 2;
                                    switch(_obj.object_index)
                                    {
                                        case Obj_Ore: // 광석 채집 처리.
                                        {if (_ins.object_index == Obj_0) {_action = 9;} break;}
                                        case Obj_101: // 원유 채집 처리.
                                        {if (_ins.object_index == Obj_0) &amp;&amp; (_obj.build == 2) {_action = 9;} else {_action = 8;} break;}
                                        case Obj_5: // 탑승물 처리.
                                        {if (_ins.slot != -1) &amp;&amp; ((_ins.slot + _obj.slot_number) &lt;= _obj.slot_max) {_action = 10;} else {_action = 0;} break;}
                                    }
                                        
                                    if (_ins.object_index == Obj_0)
                                    &amp;&amp; (_action == 2)
                                    &amp;&amp; (object_get_parent(_obj.object_index) == Obj_Building)
                                    {
                                        _action = 8; // 수리 처리.
                                    }

                                    buffer_write(global.action_command, buffer_u16, _action);
                                    buffer_write(global.action_command, buffer_u16, _ins.set_id);
                                    buffer_write(global.action_command, buffer_s16, _obj.x);
                                    buffer_write(global.action_command, buffer_s16, _obj.y);
                                }
                            }
                        }
                        else
                        {
                            for(var _j = 0; _j &lt; _size; _j ++) // 이동 명령.
                            {
                                var _ins = ds_list_find_value(select_list, _j);
                                if(instance_exists(_ins) == true)
                                {
                                    buffer_write(global.action_command, buffer_u16, 2);
                                    buffer_write(global.action_command, buffer_u16, _ins.set_id);
                                    buffer_write(global.action_command, buffer_s16, mx[_i]);
                                    buffer_write(global.action_command, buffer_s16, my[_i]);
                                }
                            }
                        }
                        click_push[_i] = true;
                    }
                }
                else if (mbr_L[_i] == true)
                &amp;&amp; (click_push[0] == false)
                &amp;&amp; (click_push[1] == false)
                &amp;&amp; (click_mbp == true) // 마우스를 때었을 때.
                {
                    while(true) // build가 0인 유닛은 제외.
                    {
                        var _ins = instance_position(mx[_i], my[_i], Obj_Sight);
                        if (instance_exists(_ins) == true) 
                        &amp;&amp; (ds_grid_get(fog_grid, _ins.f_x, _ins.f_y) == 0) 
                        {
                            if (_ins.build == 0) {instance_deactivate_object(_ins);}
                            else {instance_activate_all(); break;}
                        } else {_ins = noone; instance_activate_all(); break;}
                    }
                    
                    if (instance_exists(_ins) == true)
                    {
                        click_prev = _ins;
                            
                        if (instance_exists(click_double) == true) &amp;&amp; (_ins == click_double) // 화면 안에 있는 똑같은 모든 유닛을 선택한다.
                        {
                            ds_list_clear(select_list);
                            var _max_check = 0; while(true)
                            {
                                var _obj = collision_rectangle(view_xview[0], view_yview[0], view_xview[0] + display_get_gui_width(), view_yview[0] + display_get_gui_height(), _ins.object_index, false, true);
                                if(instance_exists(_obj) == true) &amp;&amp; (_max_check &lt; select_max)
                                {
                                    var _parent = object_get_parent(_obj.object_index);
                                    if (global.set_player == _obj.set_player) || (_parent == Obj_Resource)
                                    {
                                        var _index = ds_list_find_index(select_list, _obj);
                                        if (_index == -1) // 이미 리스트에 들어가있는 유닛인지 확인.
                                        {
                                            if (_parent == Obj_Unit) || (_parent == Obj_Resource)
                                            &amp;&amp; (ds_grid_get(fog_grid, _obj.f_x, _obj.f_y) == 0)
                                            {
                                                ds_list_add(select_list, _obj);
                                                _max_check ++;
                                            }
                                            else if (_parent == Obj_Building) 
                                            &amp;&amp; (click_double.build == _obj.build)
                                            {
                                                ds_list_add(select_list, _obj);
                                                _max_check ++;
                                            }
                                        }
                                    } instance_deactivate_object(_obj);
                                } else {instance_activate_object(all); click_double = noone; break;}
                            }
                        }
                        else
                        {
                            if (ds_grid_get(fog_grid, _ins.f_x, _ins.f_y) == 0)
                            {
                                ds_list_clear(select_list);
                                ds_list_add(select_list, _ins);
                                
                                var _parent = object_get_parent(_ins.object_index);
                                if (global.set_player == _ins.set_player) || (_parent == Obj_Resource)
                                {
                                    click_double = _ins;
                                }
                            }
                        }
                    }
                    else // 없다면 이동 명령.
                    {
                        var _size = ds_list_size(select_list);
                        for(var _j = 0; _j &lt; _size; _j ++) // 이동 명령.
                        {
                            var _ins = ds_list_find_value(select_list, _j);
                            if(instance_exists(_ins) == true) 
                            &amp;&amp; (global.set_player == _ins.set_player)
                            &amp;&amp; (_ins.build != 0)
                            {
                                buffer_write(global.action_command, buffer_u16, 1);
                                buffer_write(global.action_command, buffer_u16, _ins.set_id);
                                buffer_write(global.action_command, buffer_s16, mx[_i]);
                                buffer_write(global.action_command, buffer_s16, my[_i]);
                            }
                        }
                    }
                }
            }
            if (click_mini_map == false) {break;}
        }
        
        // 드래그 기능 시작.
        if ((select_drag == true) &amp;&amp; (mbc_L[_i] == false) &amp;&amp; (mbc_L[_k] == false))
        {
            ds_list_clear(select_list);
            var _max_check = 0; while(true)
            {
                var _ins = collision_rectangle(mx[_i], my[_i], mx[_k], my[_k], Obj_Unit, false, true);
                if (instance_exists(_ins) == true) 
                &amp;&amp; (_max_check &lt; select_max)
                &amp;&amp; (_ins.build != 0)
                {
                    if(global.set_player == _ins.set_player) &amp;&amp; (ds_grid_get(fog_grid, _ins.f_x, _ins.f_y) == 0) &amp;&amp; (_ins.build != 0)
                    {
                        var _index = ds_list_find_index(select_list, _ins);
                        if (_index == -1) // 이미 리스트에 들어가있는 유닛인지 확인.
                        {
                            ds_list_add(select_list, _ins);
                            _max_check ++;
                        }
                    }
                    instance_deactivate_object(_ins);;
                } else {instance_activate_object(all); break;}
            }
            select_drag = false;
        }
        
        for(var _i = 0; _i &lt;= 1; _i ++)
        {
            if (mbc_L[_i] == true) {click_push_time[_i] ++;}
            else if (mbr_L[_i] == true) {click_push[_i] = false; click_push_time[_i] = 0;}
        }
        
        if (mbr_L[0] == true) {click_mbp = false;}
        if (click_double != noone)
        {
            click_double_time ++;
            if (click_double_time &gt;= (0.4 * room_speed)) {click_double = noone;}
        } else {click_double_time = noone;}
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 미니맵 클릭 및 화면 축소 확대 기능입니다.
if (global.draw_gui == true) &amp;&amp; (global.lock_step == false)
{
    var _vx = mini_fog_x; // 미니맵 X 좌표. 
    var _vy = mini_fog_y; // 미니맵 Y 좌표.
    var _vw = view_wview[0]; // 미니맵 가로 크기. 
    var _vh = view_hview[0]; // 미니맵 세로 크기.
    var _w = mini_fog_width;
    var _h = mini_fog_height;
    
    // 화면 이동 기능.
    var _i = 0; _k = 1;
    if (mbp_L[_i] == true) {mouse_x_pre = mx[_i]; mouse_y_pre = my[_i]; sc_x = 0; sc_y = 0;}
    else if (mbc_L[_i] == true &amp;&amp; mbc_L[_k] == false &amp;&amp; real_dis == 0 &amp;&amp; sc_on == true)
    {
        var _sc_speed_x = 20; // X축 스크롤 속도.
        var _sc_speed_y = 25; // Y축 스크롤 속도.
        var _sc_range = 40; // 부드럽게 움직이기 위해 빼주는 픽셀.
        var _mouse_rx = point_distance(mx[_i], 0, mouse_x_pre, 0) / _sc_range;
        var _mouse_ry = point_distance(my[_i], 0, mouse_y_pre, 0) / _sc_range;
        
        if mx[_i] &lt; mouse_x_pre
        {sc_x += floor(_mouse_rx * _sc_speed_x); mouse_x_pre = mx[_i];}
        else if mx[_i] &gt; mouse_x_pre
        {sc_x -= floor(_mouse_rx * _sc_speed_x); mouse_x_pre = mx[_i];}
        
        if my[_i] &lt; mouse_y_pre
        {sc_y += floor(_mouse_ry * _sc_speed_y); mouse_y_pre = my[_i];}
        else if my[_i] &gt; mouse_y_pre
        {sc_y -= floor(_mouse_ry * _sc_speed_y); mouse_y_pre = my[_i];}
    }
    
    // 최소 스크롤 온 간격.
    if (mbc_L[_i] == true) &amp;&amp; (select_drag == false) &amp;&amp; (click_mini_map == false) &amp;&amp; (group_check == false) &amp;&amp; (screen_zoom_pressed == false) &amp;&amp; (point_distance(mx[_i], my[_i], mouse_x_pre, mouse_y_pre) &gt; 24) &amp;&amp; (sc_on == false) {view_switch = false; sc_on = true;}
    
    // 뷰 확대 축소.
    view_xview[0] -= round((((zoom_x_out - (zoom_x_in * cont_dis)) - view_wview[0]) / 4) / 2);
    view_yview[0] -= round((((zoom_y_out - (zoom_y_in * cont_dis)) - view_hview[0]) / 4) / 2);
    view_wview[0] += round(((zoom_x_out - (zoom_x_in * cont_dis)) - view_wview[0]) / 4);
    view_hview[0] += round(((zoom_y_out - (zoom_y_in * cont_dis)) - view_hview[0]) / 4);
    
    // 미니맵 이동(마우스를 클릭했을 경우)
    var _i = 0; var _k = 1;
    if (mbc_L[_i] == true) &amp;&amp; (mbc_L[_k] == false) &amp;&amp; (sc_on == false) &amp;&amp; (screen_zoom_pressed == false) &amp;&amp; (mx_gui[_i] &gt; _vx &amp;&amp; my_gui[_i] &gt; _vy &amp;&amp; mx_gui[_i] &lt; _vx + _w &amp;&amp; my_gui[_i] &lt; _vy + _h)
    {
        var _x = floor(((mx_gui[_i] - _vx) * room_width) / _w);
        var _y = floor(((my_gui[_i] - _vy) * room_height) / _h);
        view_xview[0] = max(0, min(_x - (_vw / 2), room_width - _vw));
        view_yview[0] = max(0, min(_y - (_vh / 2), room_height - _vh));
        view_switch = false;
        click_mini_map = true;
    } else if (mbc_L[_i] == false) {click_mini_map = false;}
    
    // 뷰 고정.
    view_xview[0] = round(min(max(0, view_xview[0] + sc_x), room_width - view_wview[0]));
    view_yview[0] = round(min(max(0, view_yview[0] + sc_y), room_height - (view_hview[0])));
    
    sc_x -= (sc_x / 20); sc_y -= (sc_y / 20);
    cont_dis += real_dis; if (cont_dis &gt;= 1) {cont_dis = 1;} else if (cont_dis &lt;= -1) {cont_dis = -1;}
    
    if (mini_fog_draw == false)
    {
        view_xview[0] = 0;
        view_yview[0] = 0;
        view_wview[0] = room_width;
        view_hview[0] = room_height;
    }
    
    fog_view_width = ceil(view_wview[0] / fog_scale); // 화면 넓이, 나눕니다.
    fog_view_height = ceil(view_hview[0] / fog_scale); // 화면 높이, 나눕니다.
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 타일을 드로우합니다.
if (surface_exists(tile_surface) == false) // 서피스가 존재하지 않을 경우, 다시 그립니다.
{
    tile_surface = surface_create(room_width, room_height); // 화면 크기의 서피스를 생성합니다.

    surface_set_target(tile_surface);
    var _tile_x = 0; // 화면 X 좌표.
    var _tile_y = 0; // 화면 Y 좌표.
    var _tile_w = ceil(room_width / fog_scale); // 화면 넓이.
    var _tile_h = ceil(room_height / fog_scale); // 화면 높이.
    
    for (var _j = _tile_y; _j &lt; _tile_h; _j ++)
    {
        for (var _i = _tile_x; _i &lt; _tile_w; _i ++)
        {
            if ((_i &gt;= 0 &amp;&amp; _j &gt;= 0)) &amp;&amp; (_i &lt; fog_room_width &amp;&amp; _j &lt; fog_room_height)
            {
                var _x = (_i * fog_scale);
                var _y = (_j * fog_scale);
                switch(tile_table[_i, _j])
                {
                    // 땅.
                    case 0: draw_sprite(Spr_Tile_Grass, 0, _x, _y); break;
                    case 1: draw_sprite(Spr_Tile_Grass, 1, _x, _y); break;
                    case 2: draw_sprite(Spr_Tile_Grass, 2, _x, _y); break;
                    case 3: draw_sprite(Spr_Tile_Grass, 3, _x, _y); break;
                    case 4: draw_sprite(Spr_Tile_Grass, 4, _x, _y); break;
                    case 5: draw_sprite(Spr_Tile_Grass, 5, _x, _y); break;
                    case 6: draw_sprite(Spr_Tile_Grass, 6, _x, _y); break;
                    case 7: draw_sprite(Spr_Tile_Grass, 7, _x, _y); break;
                    case 8: draw_sprite(Spr_Tile_Grass, 8, _x, _y); break;
                    case 9: draw_sprite(Spr_Tile_Grass, 9, _x, _y); break;
                    case 10: draw_sprite(Spr_Tile_Grass, 10, _x, _y); break;
                    case 11: draw_sprite(Spr_Tile_Grass, 11, _x, _y); break;
                    case 12: draw_sprite(Spr_Tile_Grass, 12, _x, _y); break;
                    case 13: draw_sprite(Spr_Tile_Grass, 13, _x, _y); break;
                    
                    // 물.
                    case 20: draw_sprite(Spr_Tile_Water, 0, _x, _y); break;
                    case 21: draw_sprite(Spr_Tile_Water, 1, _x, _y); break;
                    
                    // 언덕.
                    case 30: draw_sprite(Spr_Tile_Mount, 0, _x, _y); break;
                }
            }
        }
    }
    surface_reset_target();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 지속적으로 회색 안개로 덮습니다.
// 덮는 이유는 안 보이는 장소를 다시 안개로 덮기 위함입니다.
// 안개를 걷히는 함수는 시스템이 관리합니다.
var _list_size = ds_list_size(global.list_sight_alarm);
for(var _i = 0; _i &lt; _list_size; _i += 2)
{
    var _id = ds_list_find_value(global.list_sight_alarm, _i);
    if (instance_exists(_id) == true)
    {
        var _x = _id.f_x;
        var _y = _id.f_y;
        var _sight = 1;
        
        for(var _m = (_x - _sight); _m &lt;= (_x + _sight); _m ++)
        {
            for(var _n = (_y -_sight); _n &lt;= (_y + _sight); _n ++)
            {
                if ((_m &gt;= 0 &amp;&amp; _n &gt;= 0) &amp;&amp; (_m &lt;= fog_room_width &amp;&amp; _n &lt;= fog_room_height))
                {
                    ds_grid_set(fog_grid, _m, _n, 1);
                }
            }
        }
    }
}

var _list_size = ds_list_size(global.list_sight);
for(var _i = 0; _i &lt; _list_size; _i ++)
{
    var _id = ds_list_find_value(global.list_sight, _i);
    if (instance_exists(_id) == true)
    {
        var _x = _id.f_x;
        var _y = _id.f_y;
        var _sight = _id.sight_range;
        
        for(var _m = (_x - _sight); _m &lt;= (_x + _sight); _m ++)
        {
            for(var _n = (_y -_sight); _n &lt;= (_y + _sight); _n ++)
            {
                if ((_m &gt;= 0 &amp;&amp; _n &gt;= 0) &amp;&amp; (_m &lt;= fog_room_width &amp;&amp; _n &lt;= fog_room_height))
                {
                    /*
                    if (_m == (_x - _sight)) &amp;&amp; ((_n == (_y - _sight)) || (_n == (_y + _sight)))
                    || (_m == (_x + _sight)) &amp;&amp; ((_n == (_y - _sight)) || (_n == (_y + _sight)))
                    {continue;}
                    */
                    
                    ds_grid_set(fog_grid, _m, _n, 1);
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 미니맵 백그라운드, 안개 서피스를 화면에 표시합니다.
if (mini_fog_draw == false) // 미니맵 백그라운드를 처음에 드로우 합니다,
{
    var _sur = surface_create(display_get_gui_width(), display_get_gui_height());
    surface_set_target(_sur);
    draw_clear_alpha(c_black, 1);
    surface_copy(_sur, 0, 0, application_surface);
    surface_save(_sur, "map_image.png");
    mini_fog_sprite = sprite_add("map_image.png", 0, 0, 0, 0, 0);
    mini_fog_sprite_width = sprite_get_width(mini_fog_sprite);
    mini_fog_sprite_height = sprite_get_height(mini_fog_sprite);
    mini_fog_sprite_x_scale = (mini_fog_width / mini_fog_sprite_width);
    mini_fog_sprite_y_scale = (mini_fog_height / mini_fog_sprite_height);
    surface_reset_target();
    instance_activate_all();
    surface_free(_sur);
    
    draw_tile_x_num = 1;
    draw_tile_y_num = 6;
    mini_fog_draw = true;
}

if (surface_exists(fog_surface) == true)
{
    draw_set_blend_mode(bm_subtract);
    draw_surface(fog_surface, 0, 0);
    draw_set_blend_mode(bm_normal);
}

// 초기화.
draw_set_colour(c_black);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 마우스 효과 드로우.
if (global.draw_gui == true)
{
    var _i = 0; var _k = 1;
    if (select_drag == true)
    {
        draw_set_colour(c_lime);
        draw_rectangle(mx[_i], my[_i], mx[_k], my[_k], true);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// HP 드로우.
if (global.draw_gui == true)
{
    var _list_size = ds_list_size(select_list);
    if (_list_size &gt; 0)
    {
        for(var _i = 0; _i &lt; _list_size; _i ++)
        {
            var _ins = ds_list_find_value(select_list, _i);
            if (instance_exists(_ins) == true)
            {
                if ((view_xview[0] &lt;= _ins.bbox_right &amp;&amp; _ins.bbox_left &lt;= view_xview[0] + view_wview[0] &amp;&amp; view_yview[0] &lt;= _ins.bbox_bottom &amp;&amp; _ins.bbox_top &lt;= view_yview[0] + view_hview[0]) 
                &amp;&amp; (ds_grid_get(fog_grid, _ins.f_x, _ins.f_y) == 0))
                {
                    var _x_point_left = floor(_ins.x - _ins.draw_hp_bar_width);
                    var _x_point_right = floor(_ins.x + _ins.draw_hp_bar_width);
                    var _y_point = floor(_ins.y - _ins.draw_hp_bar_y);
                    draw_healthbar(_x_point_left, _y_point - 8, _x_point_right, _y_point, (_ins.hp / _ins.hp_max) * 100, c_black, c_red, c_lime, 0, true, true);
                    if (_ins.mp_max &gt; 0)
                    {
                        draw_healthbar(_x_point_left, _y_point + 4, _x_point_right, _y_point, floor((_ins.mp / _ins.mp_max) * 100), c_black, c_blue, c_blue, 0, true, true);
                    }
                    
                    if (_ins.object_index == Obj_101)
                    {
                        draw_healthbar(_x_point_left, _y_point + 4, _x_point_right, _y_point, floor((_ins.resource_value / _ins.resource_value_max) * 100), c_black, c_aqua, c_aqua, 0, true, true);
                    }
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 건물 건설 위치 설정.
if (global.draw_gui == true)
{
    if (instance_exists(build_id) == true)
    {
        if (build_target != noone)
        {
            var _x = (fog_scale / 2) + (floor(build_x / build_grid) * build_grid);
            var _y = (fog_scale / 2) + (floor(build_y / build_grid) * build_grid);
            var _spr = object_get_sprite(build_target);
            var _bbox_left = sprite_get_bbox_left(_spr);
            var _bbox_right = sprite_get_bbox_right(_spr);
            var _bbox_top = sprite_get_bbox_top(_spr);
            var _bbox_bottom = sprite_get_bbox_bottom(_spr);
            var _x_offset = sprite_get_xoffset(_spr);
            var _y_offset = sprite_get_yoffset(_spr)
            
            var _check_left = _x - (_x_offset - _bbox_left);
            var _check_right = _x + (_bbox_right - _x_offset);
            var _check_top = _y - (_y_offset - _bbox_top);
            var _check_bottom = _y + (_bbox_bottom - _y_offset);
            var _colour = c_green;
            var _check = false;
            
            if (_check_left &gt;= 0) &amp;&amp; (_check_top &gt;= 0) &amp;&amp; (_check_right &lt;= room_width) &amp;&amp; (_check_bottom &lt;= room_height)
            {
                while(true)
                {
                    var _building_check = collision_rectangle(_check_left, _check_top, _check_right, _check_bottom, Obj_Building, false, true);
                    if (instance_exists(_building_check) == true)
                    {
                        if (_building_check.build == 0)
                        {
                            instance_deactivate_object(_building_check);
                        }
                        else {instance_activate_all(); break;}
                    } else {instance_activate_all(); break;}
                }
                
                switch(build_target)
                {
                    case Obj_100: // 자원과 거리가 떨어져 있어야 건설 가능.
                    if (_building_check == noone)
                    &amp;&amp; (collision_rectangle(_check_left, _check_top, _check_right, _check_bottom, Obj_Block, false, true) == noone)
                    &amp;&amp; (collision_rectangle(_check_left, _check_top, _check_right, _check_bottom, Obj_Resource, false, true) == noone)
                    {
                        _check = true;
                        var _ins = noone;
                        var _range = 256;
                        var _offset_range = 16;
                        draw_set_colour(c_lime);
                        draw_rectangle(_x - _range, _y - _range, _x + _range, _y + _range, true);
                        draw_set_colour(c_red);
                        for(var _i = 0; _i &lt; 3; _i ++)
                        {
                            switch(_i)
                            {
                                case 0: _ins = instance_nearest(_x, _y, Obj_Ore); break;
                                case 1: _ins = instance_nearest(_x, _y, Obj_Oil); break;
                                case 2: _ins = instance_nearest(_x, _y, Obj_101); break;
                            }
                            
                            if (instance_exists(_ins) == true)
                            {
                                draw_line(_ins.x - _offset_range, _ins.y, _ins.x + _offset_range, _ins.y);
                                draw_line(_ins.x, _ins.y - _offset_range, _ins.x, _ins.y + _offset_range);
                                
                                if (abs(_x - _ins.x) &lt; _range)
                                &amp;&amp; (abs(_y - _ins.y) &lt; _range)
                                {_check = false;}
                            }
                        }
                    }
                    break;
                    
                    case Obj_101: // 특정 위치 아니면 건설 불가.
                    var _ins = collision_rectangle(_check_left, _check_top, _check_right, _check_bottom, Obj_Oil, false, true);
                    if (instance_exists(_ins) == true)
                    {
                        draw_set_colour(c_lime);
                        draw_rectangle(_ins.bbox_left, _ins.bbox_top, _ins.bbox_right, _ins.bbox_bottom, true);
                        draw_rectangle(_check_left, _check_top, _check_right, _check_bottom, true);
                        var _point = rectangle_in_rectangle(
                        _ins.bbox_left, _ins.bbox_top, _ins.bbox_right, _ins.bbox_bottom,
                        _check_left, _check_top, _check_right, _check_bottom);

                        if (_point == 1) {_check = true;}
                    }
                    else 
                    {
                        var _ins = instance_nearest(_x, _y, Obj_Oil);
                        if (instance_exists(_ins) == true)
                        {
                            draw_set_colour(c_red);
                            draw_rectangle(_ins.bbox_left, _ins.bbox_top, _ins.bbox_right, _ins.bbox_bottom, true);    
                        }
                    }
                    break;
                    
                    default: // 그 외의 경우.
                    if (_building_check == noone)
                    &amp;&amp; (collision_rectangle(_check_left, _check_top, _check_right, _check_bottom, Obj_Block, false, true) == noone)
                    &amp;&amp; (collision_rectangle(_check_left, _check_top, _check_right, _check_bottom, Obj_Resource, false, true) == noone)
                    {
                        _check = true;
                    }
                    break;
                }
            }
            var _f_x = min(max(floor(_x / fog_scale), 0), fog_room_width);
            var _f_y = min(max(floor(_y / fog_scale), 0), fog_room_height);
            if (ds_grid_get(fog_grid, _f_x, _f_y) == 1) {_check = true;}
            if (_check == false) {_colour = c_red;}
            
            draw_sprite_ext(_spr, 0, _x, _y, 1, 1, 0, _colour, 0.6);
            
            
            var _height = sprite_get_height(_spr);
            var _button_w = 100, _button_h = 80, _button_x = 0;
            var _button_y = ((_y - _height) - _button_h) - 16;
            for (var _i = 0; _i &lt; 2; _i ++)
            {
                _button_x = _x + 10; if (_i == 0) {_button_x -= _button_w + 10;}
                _button_colour = c_green;
                if (_i == 1) 
                {
                    if (_colour == c_red) {_colour = c_maroon;}
                    _button_colour = _colour;
                }
                draw_sprite_ext(Spr_Build_Button, _i, _button_x, _button_y, 1, 1, 0, _button_colour, 0.8);
    
                if (mbr_L[0] == true)
                &amp;&amp; (mx[0] &gt; _button_x) &amp;&amp; (my[0] &gt; _button_y)
                &amp;&amp; (mx[0] &lt; _button_x + _button_w) &amp;&amp; (my[0] &lt; _button_y + _button_h)
                {
                    switch(_i)
                    {
                        case 0: // 건설 취소 버튼.
                        {
                            build_id.action = 1;
                            build_id = noone;
                            build_target = noone;
                            
                            audio_play_sound(Sou_Build_Cancel, 100, false);
                            break;
                        }
                        
                        case 1: // 건설 버튼.
                        {
                            var _resource_check = true;
                            for(var _k = 0; _k &lt; 3; _k ++)
                            {
                                var _res = (global.get_resource[global.set_player, _k] - global.get_resource_value[global.set_player, _k]);
                                if (_k == 2)
                                {
                                    var _res_max = (global.get_resource[global.set_player, 3] - global.get_resource_value[global.set_player, 3]);
                                    if !((_res + build_resource[_k]) &lt;= _res_max)
                                    {
                                        _resource_check = false;
                                        break;
                                    }
                                }
                                else if (_res &lt; build_resource[_k]) 
                                {
                                    _resource_check = false; 
                                    break;
                                }
                            }
                            
                            if (_resource_check == true)
                            {
                                if (_check == true)
                                {
                                    buffer_write(global.action_command, buffer_u16, build_index);
                                    buffer_write(global.action_command, buffer_u16, build_id.set_id);
                                    buffer_write(global.action_command, buffer_s16, _x);
                                    buffer_write(global.action_command, buffer_s16, _y);

                                    build_id = noone;
                                    build_target = noone;

                                    audio_play_sound(Sou_Build_Click, 100, false);
                                }
                                else
                                {
                                    Obj_Game_System.command_string_switch = true;
                                    Obj_Game_System.command_string = Obj_Game_System.command_string_list[3];
                                    Obj_Game_System.command_string_time = Obj_Game_System.command_string_time_max;
                                }
                            }
                            else
                            {
                                Obj_Game_System.command_string_switch = true;
                                Obj_Game_System.command_string = Obj_Game_System.command_string_list[_k];
                                Obj_Game_System.command_string_time = Obj_Game_System.command_string_time_max;
                            }
                            
                            mbr_L[0] = false;
                            break;
                        }
                    }
                }
            }
            
            if (mbr_L[0] == true) &amp;&amp; (sc_on == false)
            &amp;&amp; ((mx_gui[0] &lt; command_gui_x) || (my_gui[0] &lt; command_gui_y)) // GUI 명령창을 벗어났을 때.
            &amp;&amp; ((mx_gui[0] &gt; mini_fog_x + mini_fog_width) || (my_gui[0] &lt; mini_fog_y)) // GUI 미니맵을 벗어났을 때.
            &amp;&amp; ((mx_gui[0] &lt; group_x) || !((my_gui[0] &gt; group_y) &amp;&amp; (my_gui[0] &lt; group_height_max))) // GUI 부대창을 벗어났을 때.
            {
                build_x = mx[0];
                build_y = my[0];
            }
        }
    }
    else
    {
        build_id = noone;
        build_target = noone;
    }
    
    if (mbr_L[0] == true) {sc_on = false;}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 지속적으로 회색 안개로 제거합니다.
// 스텝중 이동 후에 다시 안개를 걷어냅니다.
// 안개를 걷히는 함수는 시스템이 관리합니다.
if (mini_fog_alarm == 0)
{
    if (surface_exists(mini_fog_surface) == false)
    {
        mini_fog_surface = surface_create(mini_fog_width, mini_fog_height);
    }
    
    surface_set_target(mini_fog_surface);
    draw_clear(c_ltgray); draw_set_colour(c_black);
}

var _x_re = 0, _y_re = 0;
var _col = noone;
var _list_size = ds_list_size(global.list_sight_alarm);
for(var _i = 0; _i &lt; _list_size; _i += 2)
{
    var _value = ds_list_find_value(global.list_sight_alarm, _i + 1);
    ds_list_replace(global.list_sight_alarm, _i + 1, _value - 1);
    var _alarm = ds_list_find_value(global.list_sight_alarm, _i + 1);
    show_debug_message(_list_size)
    var _id = ds_list_find_value(global.list_sight_alarm, _i);
    if (_id != undefined) &amp;&amp; (instance_exists(_id) == true)
    {
        var _x = _id.f_x, _y = _id.f_y;
        var _sight = 1;
        for(var _m = (_x - _sight); _m &lt;= (_x + _sight); _m ++)
        {
            for(var _n = (_y -_sight); _n &lt;= (_y + _sight); _n ++)
            {
                if ((_m &gt;= 0 &amp;&amp; _n &gt;= 0) &amp;&amp; (_m &lt;= fog_room_width &amp;&amp; _n &lt;= fog_room_height))
                {
                    if (_alarm &gt; 0)
                    {
                        ds_grid_set(fog_grid, _m, _n, 0);
                    
                        if (mini_fog_alarm == 0)
                        {
                            _x_re = (_m * other.fog_scale) * mini_fog_x_scale;
                            _y_re = (_n * other.fog_scale) * mini_fog_y_scale;
                            draw_rectangle(_x_re, _y_re, 
                            _x_re + (mini_fog_width * mini_fog_x_scale_sight), 
                            _y_re + (mini_fog_height * mini_fog_y_scale_sight), 
                            false);
                        }
                    }
                    else
                    {
                        ds_list_delete(global.list_sight_alarm, _i);
                        ds_list_delete(global.list_sight_alarm, _i);
                        _list_size = ds_list_size(global.list_sight_alarm);
                    }
                }
            }
        }
    }
    else
    {
        ds_list_delete(global.list_sight_alarm, _i);
        ds_list_delete(global.list_sight_alarm, _i);
        _list_size = ds_list_size(global.list_sight_alarm);
    }
}

var _x_re = 0, _y_re = 0;
var _col = noone;
var _list_size = ds_list_size(global.list_sight);
for(var _i = 0; _i &lt; _list_size; _i ++)
{
    var _id = ds_list_find_value(global.list_sight, _i);
    if (instance_exists(_id) == true)
    {
        var _x = _id.f_x, _y = _id.f_y;
        var _sight = _id.sight_range;
        for(var _m = (_x - _sight); _m &lt;= (_x + _sight); _m ++)
        {
            for(var _n = (_y -_sight); _n &lt;= (_y + _sight); _n ++)
            {
                if ((_m &gt;= 0 &amp;&amp; _n &gt;= 0) &amp;&amp; (_m &lt;= fog_room_width &amp;&amp; _n &lt;= fog_room_height))
                {
                    /*
                    if (_m == (_x - _sight)) &amp;&amp; ((_n == (_y - _sight)) || (_n == (_y + _sight)))
                    || (_m == (_x + _sight)) &amp;&amp; ((_n == (_y - _sight)) || (_n == (_y + _sight)))
                    {continue;}
                    */
                    
                    _x_re = (_m * other.fog_scale); 
                    _y_re = (_n * other.fog_scale);
                    _col = collision_rectangle(_x_re, _y_re, _id.x, _id.y, Obj_Floor, false, true);
                    if !((instance_exists(_col) == true) &amp;&amp; (_id.set_floor &lt; _col.set_floor))
                    {
                        ds_grid_set(fog_grid, _m, _n, 0);
                        
                        if (mini_fog_alarm == 0)
                        {
                            _x_re = _x_re * mini_fog_x_scale;
                            _y_re = _y_re * mini_fog_y_scale;
                            draw_rectangle(_x_re, _y_re, 
                            _x_re + (mini_fog_width * mini_fog_x_scale_sight), 
                            _y_re + (mini_fog_height * mini_fog_y_scale_sight), 
                            false);
                        }
                    }
                }
            }
        }
    }
}

if (mini_fog_alarm == 0)
{
    surface_reset_target();
    mini_fog_alarm = mini_fog_alarm_max;
} else {mini_fog_alarm --;}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 미니맵을 드로우합니다.
if (mini_fog_colour_alarm == 0)
{
    if (surface_exists(mini_fog_colour_surface) == false)
    {
        mini_fog_colour_surface = surface_create(mini_fog_width, mini_fog_height);
    }
    surface_set_target(mini_fog_colour_surface);
    
    draw_clear_alpha(c_white, 0);
    with(Obj_Resource)
    {
        if (0 &lt;= self.x &amp;&amp; 0 &lt;= self.y &amp;&amp; self.x &lt;= room_width &amp;&amp; self.y &lt;= room_height)
        &amp;&amp; (ds_grid_get(other.fog_grid, self.f_x, self.f_y) == 0)
        {
            var _x_cen = (bbox_right - bbox_left) / 2;
            var _y_cen = (bbox_bottom - bbox_top) / 2;
            var _x_re_left = floor((x - _x_cen) * other.mini_fog_x_scale);
            var _x_re_right = floor((x + _x_cen) * other.mini_fog_x_scale);
            var _y_re_top = floor((y - _y_cen) * other.mini_fog_y_scale);
            var _y_re_bottom = floor((y + _y_cen) * other.mini_fog_y_scale);
            
            if (object_index == Obj_Ore) {draw_set_colour(c_maroon);} else {draw_set_colour(c_navy);}
            draw_rectangle(_x_re_left, _y_re_top, _x_re_right, _y_re_bottom, false);
            draw_set_colour(c_black);
            draw_rectangle(_x_re_left, _y_re_top, _x_re_right, _y_re_bottom, true);
        }
    }
    
    with(Obj_Building)
    {
        if (0 &lt;= self.x &amp;&amp; 0 &lt;= self.y &amp;&amp; self.x &lt;= room_width &amp;&amp; self.y &lt;= room_height)
        &amp;&amp; ((ds_grid_get(other.fog_grid, self.f_x, self.f_y) == 0)
        || (ds_grid_get(other.fog_grid, self.f_x, self.f_y) == 1)) 
        {
            if (build &gt; 0) &amp;&amp; (vision == true)
            {
                var _x_cen = (bbox_right - bbox_left) / 2;
                var _y_cen = (bbox_bottom - bbox_top) / 2;
                var _x_re_left = floor((x - _x_cen) * other.mini_fog_x_scale);
                var _x_re_right = floor((x + _x_cen) * other.mini_fog_x_scale);
                var _y_re_top = floor((y - _y_cen) * other.mini_fog_y_scale);
                var _y_re_bottom = floor((y + _y_cen) * other.mini_fog_y_scale);
                
                draw_set_colour(global.get_colour_draw[self.set_colour]);
                draw_rectangle(_x_re_left, _y_re_top, _x_re_right, _y_re_bottom, false);
                draw_set_colour(c_black);
                draw_rectangle(_x_re_left, _y_re_top, _x_re_right, _y_re_bottom, true);
            }
        }
    }
    
    with(Obj_Unit)
    {
        if (0 &lt;= self.x &amp;&amp; 0 &lt;= self.y &amp;&amp; self.x &lt;= room_width &amp;&amp; self.y &lt;= room_height)
        &amp;&amp; (ds_grid_get(other.fog_grid, self.f_x, self.f_y) == 0)
        {
            var _x_cen = (bbox_right - bbox_left) / 2;
            var _y_cen = (bbox_bottom - bbox_top) / 2;
            var _x_re_left = floor((x - _x_cen) * other.mini_fog_x_scale);
            var _x_re_right = floor((x + _x_cen) * other.mini_fog_x_scale);
            var _y_re_top = floor((y - _y_cen) * other.mini_fog_y_scale);
            var _y_re_bottom = floor((y + _y_cen) * other.mini_fog_y_scale);
            
            draw_set_colour(global.get_colour_draw[self.set_colour]);
            draw_rectangle(_x_re_left, _y_re_top, _x_re_right, _y_re_bottom, false);
            draw_set_colour(c_black);
            draw_rectangle(_x_re_left, _y_re_top, _x_re_right, _y_re_bottom, true);
        }
    }
    surface_reset_target();
    mini_fog_colour_alarm = mini_fog_colour_alarm_max;
} else {mini_fog_colour_alarm --;}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 안개를 드로우합니다.
if (fog_step_alarm == 0)
{
    var _fog_x = floor(view_xview[0] / fog_scale); // 화면 X 좌표.
    var _fog_y = floor(view_yview[0] / fog_scale); // 화면 Y 좌표.
    var _fog_view_x = ceil((view_xview[0] + view_wview[0]) / fog_scale) - 1; // 화면의 X 좌표 안개 갯수 + 화면의 넓이 안개 갯수.
    var _fog_view_y = ceil((view_yview[0] + view_hview[0]) / fog_scale) - 1; // 화면의 Y 좌표 안개 갯수 + 화면의 높이 안개 갯수.

    if (surface_exists(fog_surface) == false) // 서피스가 존재하지 않을 경우, 다시 그립니다.
    {
        fog_surface = surface_create(room_width, room_height); // 화면 크기의 서피스를 생성합니다.
    }
    surface_set_target(fog_surface);
    draw_clear(c_black); // 서피스 화면을 검은색으로 채웁니다.
    
    if (sprite_exists(fog_sprite) == false) // 스프라이트가 지워졌을 경우.
    {
        fog_sprite = sprite_duplicate(Spr_Fog); // 시야 스프라이트.
        var _fog_mask_sprite = sprite_duplicate(Spr_Fog_Mask); // 시야 스프라이트에 적용할 마스크.
        sprite_set_alpha_from_sprite(fog_sprite, _fog_mask_sprite); // 시야 스프라이트에 마스크 설정.
        sprite_delete(_fog_mask_sprite); // 사용한 마스크 이미지는 삭제.
    }

    if (mini_fog_draw == true)
    {
        //var _alpha = 0; _speed = 0.2;
        var _fog_scale_div = (fog_scale / 2);
        for (var _j = _fog_y; _j &lt;= _fog_view_y; _j ++)
        {
            for (var _i = _fog_x; _i &lt;= _fog_view_x; _i ++)
            {
                if ((_i &gt;= 0 &amp;&amp; _j &gt;= 0) &amp;&amp; (_i &lt;= fog_room_width &amp;&amp; _j &lt;= fog_room_height))
                {
                    var _x = (_i * fog_scale) - _fog_scale_div;
                    var _y = (_j * fog_scale) - _fog_scale_div;
                    
                    /*
                    if (0 == ds_grid_get(fog_grid, _i, _j))
                    {
                        while(true)
                        {
                            var _line = noone;
                            var _col = noone;
                            var _ins = instance_nearest(_x, _y, Obj_Sight);
                            if (instance_exists(_ins) == true)
                            {
                                var _xx = _ins.x;
                                var _yy = _ins.y;
                                if (point_distance(_x, _y, _xx, _yy) &lt;= 10 * 64)
                                {
                                    if (global.set_player == _ins.set_player)
                                    {
                                        var _col = collision_line(_x, _y, _xx, _yy, Obj_Mount, false, true);
                                        if (instance_exists(_col) == true)
                                        {
                                            instance_deactivate_object(_ins);
                                        } else {_col = noone; break;}
                                    } else {instance_deactivate_object(_ins);}
                                } else {break;}
                            } else {break;}
                        }
                        instance_activate_all(); 
                        
                        if (_col != noone)
                        {
                            draw_sprite_ext(fog_sprite, 0, _x, _y, fog_quality, fog_quality, 0, c_gray, 1);
                        }
                    }
                    else*/
                    if (1 == ds_grid_get(fog_grid, _i, _j))
                    {
                        draw_sprite_ext(fog_sprite, 0, _x, _y, fog_quality, fog_quality, 0, c_ltgray, 1);
                    }
                    
                    /*
                    _alpha = ds_grid_get(fog_alpha, _i, _j);
                    switch(ds_grid_get(fog_grid, _i, _j))
                    {
                        // 탐색한 구역. (회색 안개로 채웁니다.)
                        case 0: if (_alpha &gt; 0) {_alpha = _speed;} break;
            
                        // 탐색하지 못한 구역. (검은색 안개로 채웁니다.)
                        case 1: if (_alpha &lt; 1) {_alpha += _speed;} break;
                    }
                    if (_alpha &gt; 0)
                    {
                        draw_sprite_ext(fog_sprite, 0, (_i * fog_scale) - view_xview[0], (_j * fog_scale) - view_yview[0], fog_quality, fog_quality, 0, c_gray, _alpha);
                    }
                    ds_grid_set(fog_alpha, _i, _j, _alpha);
                    */
                }
            }
        }
    }
    surface_reset_target();
    fog_step_alarm = fog_step_alarm_max;
} else {fog_step_alarm --;}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 미니맵을 화면에 표시합니다.
if (global.draw_gui == true)
{
    draw_set_alpha(gui_alpha);
    
    // 미니맵 백 그라운드 이미지.
    if (mini_fog_draw == true)
    {draw_sprite_ext(mini_fog_sprite, 0, mini_fog_x, mini_fog_y, mini_fog_sprite_x_scale, mini_fog_sprite_y_scale, 0, c_white, gui_alpha);}
    
    // 미니맵 외각 부분 색.
    draw_set_colour(c_white);
    draw_rectangle(mini_fog_x - 1, mini_fog_y - 1, mini_fog_x + mini_fog_width, mini_fog_y + mini_fog_height, true);
    
    // 미니맵 컬러 서피스 드로우.
    if (surface_exists(mini_fog_colour_surface) == true)
    {
        draw_surface(mini_fog_colour_surface, mini_fog_x, mini_fog_y);
    }
    
    // 미니맵 서피스 드로우.
    if (surface_exists(mini_fog_surface) == true)
    {
        draw_set_blend_mode(bm_subtract);
        draw_surface(mini_fog_surface, mini_fog_x, mini_fog_y);
        draw_set_blend_mode(bm_normal);
        
    }

    // 미니맵 보고 있는 시야 부분 색.
    var _px = view_xview[0] * mini_fog_x_scale; 
    var _py = view_yview[0] * mini_fog_y_scale;
    var _pw = (view_xview[0] + view_wview[0]) * mini_fog_x_scale; 
    var _ph = (view_yview[0] + view_hview[0]) * mini_fog_y_scale;
    draw_rectangle(mini_fog_x + _px, mini_fog_y + _py, mini_fog_x + _pw, mini_fog_y + _ph, true);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// GUI를 화면에 표시합니다.
if (global.draw_gui == true)
{
    // 부대 지정.
    var _m = 0, _n = 1, _check = false;
    for(var _i = 0; _i &lt; group_max; _i ++)
    {
        draw_set_alpha(gui_alpha);
        var _w = group_width, _h = group_height;
        var _x = group_x, _y = group_y + ((group_length + _h) * _i);
        
        var _id = noone;
        var _size = ds_list_size(group_list[_i]);
        for(var _k = 0; _k &lt; _size; _k ++)
        {
            var _value = ds_list_find_value(group_list[_i], _k);
            if (_value != undefined) &amp;&amp; (instance_exists(_value) == true)
            {
                if (_id == noone) {_id = _value.id;}
            
                if (_value.priority &gt; _id.priority)
                {
                    _id = _value.id;
                }
            } else {ds_list_delete(group_list[_i], ds_list_find_index(group_list[_i], _value));}
        }
        
        if (mbc_L[_m] == true)
        &amp;&amp; (group_pressed[_i] == true)
        {
            if (instance_exists(_id) == true)
            &amp;&amp; (group_camera[_i] == true)
            {
                view_xview[0] = min(room_width - view_wview[0], max(0, _id.x - (view_wview[0] / 2))); 
                view_yview[0] = min(room_height - view_hview[0], max(0, _id.y - (view_hview[0] / 2)));
            }
                    
            if (abs(group_pressed_y[_i] - my_gui[_m]) &gt;= group_pressed_y_lenth[_i])
            {
                var _s_size = ds_list_size(select_list);
                var _sign = sign(group_pressed_y[_i] - my_gui[_m]);
                if (_sign &gt; 0)
                {
                    for(var _k = 0; _k &lt; _s_size; _k ++)
                    {
                        var _index = ds_list_find_value(select_list, _k);
                        if (global.set_player == _index.set_player)
                        {
                            var _value = ds_list_find_index(group_list[_i], _index);
                            if (_value == -1)
                            {
                                ds_list_add(group_list[_i], _index.id);
                            }
                        }
                    }
                    group_pressed_y_anim_switch[_i] = 1;
                }
                else
                {
                    for(var _k = 0; _k &lt; _s_size; _k ++)
                    {
                        var _index = ds_list_find_value(select_list, _k);
                        if (global.set_player == _index.set_player)
                        {
                            var _value = ds_list_find_index(group_list[_i], _index);
                            if (_value != -1)
                            {
                                ds_list_delete(group_list[_i], _value);
                            }
                        }
                    }
                    group_pressed_y_anim_switch[_i] = 2;
                }
                group_pressed_y_anim_fade[_i] = 1;
            }
        }
        
        if (global.lock_step == false)
        &amp;&amp; (mbp_L[_m] == true)
        {
            if (_x &lt; mx_gui[_m]) &amp;&amp; (_y &lt; my_gui[_m])
            &amp;&amp; (mx_gui[_m] &lt; (_x + _w)) &amp;&amp; (my_gui[_m] &lt; (_y + _h))
            {
                if(instance_exists(build_id) == true)
                {
                    build_id.action = 0;
                    build_id = noone;
                    build_target = noone;
                }
                
                group_pressed[_i] = true;
                group_pressed_y[_i] = my_gui[_m];
                
                if (group_double_tab_time[_i] &gt; 0)
                {
                    group_camera[_i] = true;
                }
                group_double_tab_time[_i] = group_double_tab_time_max[_i];
            }
        }
        
        if (mbr_L[_m] == true)
        &amp;&amp; (group_pressed[_i] == true)
        {
            if (_x &lt; mx_gui[_m]) &amp;&amp; (_y &lt; my_gui[_m])
            &amp;&amp; (mx_gui[_m] &lt; (_x + _w)) &amp;&amp; (my_gui[_m] &lt; (_y + _h))
            {
                ds_list_clear(select_list);
                ds_list_copy(select_list, group_list[_i]);
                group_pressed_y_anim_switch[_i] = 3;
            }
            group_pressed_y_anim_fade[_i] = 1;
            group_pressed[_i] = false;
            group_camera[_i] = false;
        }
        
        var _col_i = c_dkgray, _col_o = c_white;
        if (group_pressed[_i] == true) {_col_i = c_gray;}
        draw_set_colour(_col_i);
        draw_rectangle(_x, _y, _x + _w, _y + _h, false);
        draw_set_colour(_col_o);
        draw_rectangle(_x, _y, _x + _w, _y + _h, true);
        
        var _font = font_gui_command; draw_set_font(_font);
        var _font = font_get_texture(_font);
        var _texel_width = texture_get_texel_width(_font);
        var _texel_height = texture_get_texel_height(_font);
        var _texture = shader_get_uniform(shader_set_font, "v_TexturePixelSize");
    
        if (instance_exists(_id) == true)
        {
            var _parent = object_get_parent(_id.object_index);
            var _spr = noone;
            if (_parent == Obj_Building)
            {
                _spr = Spr_Build_Stat;
            }
            else if (_parent == Obj_Unit)
            {
                _spr = Spr_Unit_Stat;
            }
            
            shader_set(shader_set_colour);
            shader_set_uniform_f(colour_to_find, 1, 0, 0);       
            shader_set_uniform_f(colour_to_set, global.get_colour_rgb[_id.set_colour, 0], global.get_colour_rgb[_id.set_colour, 1], global.get_colour_rgb[_id.set_colour, 2]); // R, G, B.
            
            var _index = _id.gui_sprite;
            draw_sprite_ext(_spr, _index, _x, _y, 0.84, 0.84, 0, c_white, gui_alpha);
            
            shader_reset();
            
            shader_set(shader_set_font);        
            shader_enable_corner_id(true);
            shader_set_uniform_f(_texture, _texel_width, _texel_height);
        
            draw_set_colour(c_white); 
            draw_set_halign(fa_center); 
            draw_set_valign(fa_top);
    
            draw_text(_x + (_w / 2), _y, string(_id.name));
            
            draw_set_valign(fa_bottom);
            draw_text(_x + (_w / 2), _y + _h, "[ " + string(_size) + " ]");
            
            shader_reset();
            shader_enable_corner_id(false);          
        }
        
        // 위, 아래 애니메이션 표시.
        draw_set_alpha(group_pressed_y_anim_fade[_i]);
        if (group_pressed_y_anim_switch[_i] == 1)
        {
            draw_rectangle(_x, _y + (_h / 2), _x - _w, _y, false);
        }
        else if (group_pressed_y_anim_switch[_i] == 2)
        {
            draw_rectangle(_x, _y + (_h / 2), _x - _w, _y + _h, false);
        }
        else if (group_pressed_y_anim_switch[_i] == 3)
        {
            draw_rectangle(_x, _y, _x + _w, _y + _h, false);
        }
        // draw_rectangle(_x, _y, _x + _w, _y + _h, false); // 박스는 언제나 페이드 처리.
    
        if (group_pressed_y_anim_fade[_i] &gt; 0) {group_pressed_y_anim_fade[_i] -= anim_fade_speed;}
        if (group_double_tab_time[_i] &gt; 0) {group_double_tab_time[_i] --;}
        if (_check == false) &amp;&amp; (group_pressed[_i] == true) {_check = true;}
    }
    
    if (_check == true) {group_check = true;} else {group_check = false;}

    // GUI 자원 드로우입니다.
    draw_set_alpha(gui_alpha);
    var _font = font_resource; draw_set_font(_font);
    var _font = font_get_texture(_font);
    var _texel_width = texture_get_texel_width(_font);
    var _texel_height = texture_get_texel_height(_font);
    var _texture = shader_get_uniform(shader_set_font, "v_TexturePixelSize");
    var _x = command_gui_x_width, _y = (command_gui_y - 28), _speed = 20, _num = 2; // X, Y, 자원 값 변경 속도, 자원 순.
    for (var _i = 0; _i &lt; 4; _i ++) // 0: 광물, 1: 오일, 2: 인구, 3: 최대 인구.
    {
        for (var _k = 0; _k &lt; global.max_player; _k ++)
        {
            // 자원 값 자연스럽게 변경.
            if (global.get_resource_value[_k, _i] != 0)
            {
                var _value = 0;
                if (sign(global.get_resource_value[_k, _i]) == 1)
                {_value = ceil(global.get_resource_value[_k, _i] / _speed);}
                else 
                {_value = floor(global.get_resource_value[_k, _i] / _speed);}
                global.get_resource_value[_k, _i] -= _value; 
                global.get_resource[_k, _i] -= _value;
            }
            
            if (_i == 3)
            &amp;&amp; (global.get_resource[_k, _i] - global.get_resource_value[_k, _i] &gt; global.max_farm)
            {
                global.get_resource[_k, _i] = 80;
                global.get_resource_value[_k, _i] = 0;
            }
        }
        if (_i == 3) {break;}
        
        var _str = "", _str_width = 0;
        if (_num == 2) 
        {
            _str = string(string(global.get_resource[global.set_player, _num]) + " / " + string(global.get_resource[global.set_player, 3]));
        }
        else
        {
            _str = string(global.get_resource[global.set_player, _num]);
        }
        shader_set(shader_set_font);        
        shader_enable_corner_id(true);
        shader_set_uniform_f(_texture, _texel_width, _texel_height);
    
        draw_set_colour(c_white); 
        draw_set_halign(fa_right); draw_set_valign(fa_top);
        draw_text(_x, _y - 5, _str);
        
        shader_reset();
        shader_enable_corner_id(false);
    
        _str_width = string_width(_str) + 26;
        draw_sprite(Spr_GUI_Resource, _num, _x - _str_width, _y);
        _x -= _str_width + 32;
        
        _num --;
    }
    
    // 유닛중 탑승 유닛은 표기 제외.
    var _size = ds_list_size(select_list);
    for(var _i = 0; _i &lt; _size; _i ++)
    {
        var _ins = ds_list_find_value(select_list, _i);
        if (_ins != undefined) &amp;&amp; (instance_exists(_ins) == true)
        &amp;&amp; (_ins.build == 0)
        {
            ds_list_delete(select_list, _i);
            _i --;
        }
    }
        
    // 유닛 우선도 확인 후 명령창에 사용.
    var _size = ds_list_size(select_list);
    var _priority = -1, _priority_id = noone;
    for(var _i = 0; _i &lt; _size; _i ++) // 선택된 유닛 사이즈만큼 반복.
    {
        var _ins = ds_list_find_value(select_list, _i);
        if (instance_exists(_ins) == true)
        &amp;&amp; (_priority &lt; _ins.priority)
        {
            _priority = _ins.priority;
            _priority_id = _ins.id;
        }
        else
        {
            continue;
        }
    }
    
    // 아래 부가 설명창 GUI.
    var _font = font_gui_command; draw_set_font(_font);
    var _font = font_get_texture(_font);
    var _texel_width = texture_get_texel_width(_font);
    var _texel_height = texture_get_texel_height(_font);
    var _texture = shader_get_uniform(shader_set_font, "v_TexturePixelSize");
    var _w = command_gui_width, _h = command_gui_height; // 명령창 스프라이트 사이즈.
    if (_size &gt; 1) // 선택된 유닛이 하나가 아닌 경우.
    {
        shader_set(shader_set_font);
        shader_enable_corner_id(true);
        
        shader_set_uniform_f(_texture, _texel_width, _texel_height);
        
        draw_set_halign(fa_center); draw_set_valign(fa_top);
        draw_text(display_get_gui_width() / 2, command_gui_y, "선택된 유닛 수: " + string(_size));
        
        shader_reset();
        shader_enable_corner_id(false);
    }
    
    // GUI 명령창 백그라운드.
    draw_set_alpha(gui_alpha);
    draw_set_colour(c_dkgray);
    draw_rectangle(command_gui_x - 4, command_gui_y, command_gui_x_width, command_gui_y_height, false);
    draw_set_colour(c_white);
    draw_rectangle(command_gui_x - 4, command_gui_y, command_gui_x_width, command_gui_y_height, true);
    
    // 명령 GUI 코드.
    var _num = -1; // 명령창 순번.
    for(var _j = 0; _j &lt; 2; _j ++) // 세로.
    {
        for(var _k = 0; _k &lt; 4; _k ++) // 가로.
        {
            _num ++;
            
            var _m = 0, _n = 1; // 명령창을 눌렀을 경우에 구문 실행.
            var _x = (command_gui_x + (_k * (_w + 4))); // 명령창 버튼 X 좌표.
            var _y = (command_gui_y + (_j * (_h + 4)) + 4); // 명령창 버튼 Y 좌표.

            var _skip = true;
            if (instance_exists(_priority_id) == true)
            {
                _skip = false;
                var _command = _priority_id.get_command[_num];
                if (_command == -1) {_skip = true;}
                else
                {
                    var _obj = return_obj_number(_command);
                    var _number = return_csv_number(_obj);
                    var _index = real(global.sight_table[_number, return_str_number("gui_sprite")]);
                    var _return_name = string(global.sight_table[_number, return_str_number("name")]);
                    var _check_string = string(global.sight_table[_number, return_str_number("create_resource_3")]); 
                    if (real(_check_string) == 0) {_check_string = "";} else {_check_string = "/" + _check_string;}
                    var _return_resource = string(global.sight_table[_number, return_str_number("create_resource_1")]) + "/" + string(global.sight_table[_number, return_str_number("create_resource_2")]) + string(_check_string);
                }
            }
            
            if (global.lock_step == false)
            &amp;&amp; (_x &lt; mx_gui[_m]) &amp;&amp; (_y &lt; my_gui[_m])
            &amp;&amp; (mx_gui[_m] &lt; (_x + _w)) &amp;&amp; (my_gui[_m] &lt; (_y + _h))
            {
                if (mbp_L[_m] == true)
                {
                    box_pressed[_num] = true;
                }
                
                if (mbc_L[_m] == true) &amp;&amp; (box_pressed[_num] == true)
                {
                    if (box_double_tab_time[_num] &lt; box_double_tab_time_max[_num])
                    {
                        box_double_tab_time[_num] ++;
                    }
                }
            }
            if (global.lock_step == false)
            &amp;&amp; (mbr_L[_m] == true) &amp;&amp; (box_pressed[_num] == true)
            {
                box_pressed[_num] = false;
                box_pressed_anim_fade[_num] = 1;
                box_double_tab_time[_num] = 0;
            }
            
            // 설명창 오픈.
            if (_skip == false) &amp;&amp; (info_switch == true)
            &amp;&amp; (_command &gt;= 20) &amp;&amp; (box_double_tab_time[_num] == box_double_tab_time_max[_num]) 
            {
                var _info_name = _return_name;
                var _info_resource = _return_resource;
                var _info_explain = string(global.sight_table[_number, 29]);

                shader_set(shader_set_font);
                shader_enable_corner_id(true);
                
                shader_set_uniform_f(_texture, _texel_width, _texel_height);
                
                draw_set_halign(fa_left); draw_set_valign(fa_top); draw_set_colour(c_white);
                var _string = "", _string_x = 300, _string_y = 540;
                draw_text(_string_x, _string_y, "이름: " + string(global.sight_table[_number, return_str_number("name")]));
                
                _string_x = 300; _string_y = 570;
                draw_text(_string_x, _string_y, "필요 자원: " + string(global.sight_table[_number, return_str_number("create_resource_1")])
                + "/" + string(global.sight_table[_number, return_str_number("create_resource_2")])
                + "/" + string(global.sight_table[_number, return_str_number("create_resource_3")]));
                
                _string_y += 20;
                draw_text(_string_x, _string_y, "필요 시간: " + string(global.sight_table[_number, return_str_number("create_time")]));
                
                _string_y += 20;
                draw_text(_string_x, _string_y, "설명: " + string(global.sight_table[_number, return_str_number("info")]));
                
                for(var _i = 0; _i &lt; 8; _i ++)
                {
                    draw_set_halign(fa_right); draw_set_valign(fa_bottom);
                    _string = ""; _string_x = 800; _string_y = 570 + (_i * 20);
                    switch(_i)
                    {
                        case 0: _string = "체력"; break;
                        case 1: _string = "공격력"; break;
                        case 2: _string = "방어력"; break;
                        case 3: _string = "공격 타입"; break;
                        case 4: _string = "방어 타입"; break;
                        case 5: _string = "공격 사거리"; break;
                        case 6: _string = "공격 속도"; break;
                        case 7: _string = "이동 속도"; break;
                        case 8: _string = "시야"; break;
                    }
                    draw_text(_string_x, _string_y, string(_string) + ":");
        
                    _string_x = 860;
                    switch(_i)
                    {
                        case 0: _string = string(global.sight_table[_number, return_str_number("hp")]); break;
                        case 1: _string = string(global.sight_table[_number, return_str_number("atk")]); break;
                        case 2: _string = string(global.sight_table[_number, return_str_number("def")]); break;
                        case 3: _string = string(global.sight_table[_number, return_str_number("atk_type")]); break;
                        case 4: _string = string(global.sight_table[_number, return_str_number("def_type")]); break;
                        case 5: _string = string(global.sight_table[_number, return_str_number("atk_range")]); break;
                        case 6: _string = string(real(global.sight_table[_number, return_str_number("atk_speed")]) * room_speed); break;
                        case 7: _string = string(((real(global.sight_table[_number, return_str_number("move_speed")]) * global.target_fps) / room_speed)); break;
                        case 8: _string = string(real(global.sight_table[_number, return_str_number("sight")])); break;
                    } if (real(_string) &lt; 0) {_string = "없음";}
                    
                    draw_text(_string_x, _string_y, _string);
                }
                shader_reset();
                shader_enable_corner_id(false);
            }
            
            draw_set_alpha(gui_alpha);
            if (box_pressed[_num] == true)
            {
                draw_set_colour(c_gray);
                draw_rectangle(_x, _y, _x + _w, _y + _h, false);
            }
            draw_set_colour(c_white);
            draw_rectangle(_x, _y, _x + _w, _y + _h, true);
            
            if (_skip == false)
            {
                var _return_colour = c_gray;
                var _action = _priority_id.action; // 명령의 기본색은 회색이지만.
                if (_action == _command) {_return_colour = c_white;} // 선택된 명령은 흰색으로 표기합니다.
                if (_action == 10) &amp;&amp; (_command == 1) {_command = 10; _return_colour = c_white;}
                
                if (_command &gt;= 0) &amp;&amp; (_command &lt;= 19)
                {
                    var _text = ""; switch(_command)
                    {
                        case 0: _text = "정지"; break;
                        case 1: _text = "이동"; break;
                        case 2: _text = "공격"; break;
                        case 3: _text = "경계"; break;
                        case 4: _text = "취소"; break;
                        case 5: _text = "행정 건물"; break;
                        case 6: _text = "생산 건물"; break;
                        case 7: _text = "방호 건물"; break;
                        case 8: _text = "수리"; break; 
                        case 9: _text = "자원 채집"; break;
                        case 10: _text = "탑승"; break;
                        case 11: _text = "하차"; break;
                    }
                    draw_sprite_ext(Spr_Command, _command, _x, _y, 1, 0.8, 0, _return_colour, gui_alpha);
                    
                    shader_set(shader_set_font);        
                    shader_enable_corner_id(true);
                    shader_set_uniform_f(_texture, _texel_width, _texel_height);
                    
                    draw_set_halign(fa_center); 
                    draw_set_valign(fa_bottom);
                    draw_set_colour(_return_colour);

                    // 명령을 표기합니다.
                    draw_text(_x + (_w / 2), _y + _h - 4, _text);

                    shader_reset();
                    shader_enable_corner_id(false);
                }
                else
                {
                    _return_colour = c_white; // 생산 건물이면 무조건 흰색.
    
                    // 유닛 생산에 필요 조건이 불충분할 경우엔 색 어둡게 표기.
                    if ((_command == 22) &amp;&amp; (global.get_building[global.set_player, 3] == false))
                    || ((_command == 23) &amp;&amp; (global.get_building[global.set_player, 3] == false))
                    || ((_command == 24) &amp;&amp; (global.get_building[global.set_player, 3] == false))
                    || ((_command == 171) &amp;&amp; (global.get_building[global.set_player, 0] == false))
                    || ((_command == 172) &amp;&amp; (global.get_building[global.set_player, 0] == false))
                    || ((_command == 174) &amp;&amp; (global.get_building[global.set_player, 0] == false))
                    || ((_command == 173) &amp;&amp; (global.get_building[global.set_player, 1] == false))
                    || ((_command == 175) &amp;&amp; (global.get_building[global.set_player, 2] == false))
                    || ((_command == 176) &amp;&amp; (global.get_building[global.set_player, 2] == false))
                    || ((_command == 177) &amp;&amp; (global.get_building[global.set_player, 2] == false))
                    {_return_colour = c_gray;}
                    
                    if (_obj == build_target) {_return_colour = c_white;}
                    
                    shader_set(shader_set_colour);
                    shader_set_uniform_f(colour_to_find, 1, 0, 0);       
                    shader_set_uniform_f(colour_to_set, global.get_colour_rgb[_priority_id.set_colour, 0], global.get_colour_rgb[_priority_id.set_colour, 1], global.get_colour_rgb[_priority_id.set_colour, 2]); // R, G, B.
                    
                    var _sprite = Spr_Unit_Stat; 
                    var _parent = object_get_parent(_obj);
                    if (_parent == Obj_Building) {_sprite = Spr_Build_Stat;}
                    
                    draw_sprite_ext(_sprite, _index, _x, _y, 1, 1, 0, _return_colour, gui_alpha);
                    shader_reset();
                    
                    shader_set(shader_set_font);        
                    shader_enable_corner_id(true);
                    shader_set_uniform_f(_texture, _texel_width, _texel_height);
                    
                    draw_set_halign(fa_center); 
                    draw_set_valign(fa_top);
                    draw_set_colour(_return_colour);
                    
                    // 유닛일 경우 이름을 표기합니다.
                    draw_text(_x + (_w / 2), _y, _return_name);
                    
                    // 소모되는 자원량 표기합니다.
                    
                    draw_set_valign(fa_bottom);
                    draw_text(_x + (_w / 2), _y + _h, _return_resource);
                    
                    shader_reset();
                    shader_enable_corner_id(false);
                }
                
                if (mbc_L[_n] == false) &amp;&amp; (sc_on == false) 
                &amp;&amp; (_x &lt; mx_gui[_m]) &amp;&amp; (_y &lt; my_gui[_m])
                &amp;&amp; (mx_gui[_m] &lt; (_x + _w)) &amp;&amp; (my_gui[_m] &lt; (_y + _h))
                {
                    if (global.lock_step == false) &amp;&amp; (mbr_L[_m] == true) &amp;&amp; (box_pressed_anim_fade[_num] == 1)
                    {
                        var _size = ds_list_size(select_list);
                        switch(_command)
                        {
                            case 0: case 1: case 2: case 3: case 4:
                            case 5: case 6: case 7: case 8: case 9:
                            case 10: case 11: // 단순 ACTION 변경.
                            {
                                if (_command == 4)
                                &amp;&amp; (build_id != noone) || (build_target != noone)
                                {
                                    build_id = noone;
                                    build_target = noone; // 건설 위치 지정 때 취소할 시 남아있는 값 제거.
                                }
                                
                                for (var _m = 0; _m &lt; _size; _m ++)
                                {
                                    var _ins = ds_list_find_value(select_list, _m);
                                    if (global.set_player == _ins.set_player)
                                    {
                                        buffer_write(global.action_command, buffer_u16, _command);
                                        buffer_write(global.action_command, buffer_u16, _ins.set_id);
                                        buffer_write(global.action_command, buffer_s16, _ins.move_x);
                                        buffer_write(global.action_command, buffer_s16, _ins.move_y);
                                    }
                                }
                                break;
                            }
                            
                            // 유닛 생산.
                            case 20: // 시설 공병.
                            case 21: // 소총수.
                            case 22: // 갑옷 포격병.
                            case 23: // 저격수.
                            case 24: // 군의관.
                            case 25: // 장갑차.
                            case 26: // 전차.
                            case 27: // 자주포.
                            case 28: // 방사포.
                            {
                                if ((_command == 22) &amp;&amp; (global.get_building[global.set_player, 3] == false))
                                || ((_command == 23) &amp;&amp; (global.get_building[global.set_player, 3] == false))
                                || ((_command == 24) &amp;&amp; (global.get_building[global.set_player, 3] == false))
                                {break;} // 생산 조건에 해당되지 않으면 스킵.
                                
                                for(var _m = 0; _m &lt; _size; _m ++)
                                {
                                    var _ins = ds_list_find_value(select_list, _m);
                                    if (global.set_player == _ins.set_player) &amp;&amp; (Obj_Building == object_get_parent(_ins.object_index))
                                    {
                                        for(var _n = 0; _n &lt; _ins.max_produce; _n ++)
                                        { 
                                            if (_ins.waiting[_n] == noone)
                                            {
                                                buffer_write(global.action_command, buffer_u16, _command);
                                                buffer_write(global.action_command, buffer_u16, _ins.set_id);
                                                buffer_write(global.action_command, buffer_s16, _ins.move_x);
                                                buffer_write(global.action_command, buffer_s16, _ins.move_y);
                                                break;
                                            }
                                        }
                                    }
                                }
                                break;
                            }
                            default: // 건물 건설.
                            {
                                if ((_command == 171) &amp;&amp; (global.get_building[global.set_player, 0] == false))
                                || ((_command == 172) &amp;&amp; (global.get_building[global.set_player, 0] == false))
                                || ((_command == 174) &amp;&amp; (global.get_building[global.set_player, 0] == false))
                                || ((_command == 173) &amp;&amp; (global.get_building[global.set_player, 1] == false))
                                || ((_command == 175) &amp;&amp; (global.get_building[global.set_player, 2] == false))
                                || ((_command == 176) &amp;&amp; (global.get_building[global.set_player, 2] == false))
                                || ((_command == 177) &amp;&amp; (global.get_building[global.set_player, 2] == false))
                                {break;} // 생산 조건에 해당되지 않으면 스킵.
                                
                                if (_parent == Obj_Building)
                                {
                                    build_id = _priority_id;
                                    build_target = _obj;
                                    build_index = _command;
                                    build_resource[0] = real(global.sight_table[_number, return_str_number("create_resource_1")]);
                                    build_resource[1] = real(global.sight_table[_number, return_str_number("create_resource_2")]);
                                    build_resource[2] = real(global.sight_table[_number, return_str_number("create_resource_3")]);
                                    build_x = view_xview[0] + (view_wview[0] / 2);
                                    build_y = view_yview[0] + (view_hview[0] / 2);
                                }
                            }
                        }
                    }
                }
            }

            draw_set_alpha(box_pressed_anim_fade[_num]);
            draw_rectangle(_x, _y, _x + _w, _y + _h, false);
            draw_set_alpha(1);
            
            if (box_pressed[_num] == false) &amp;&amp; (box_pressed_anim_fade[_num] &gt; 0)
            {
                box_pressed_anim_fade[_num] -= anim_fade_speed;
            }
        }
    }
    // 알림 GUI 입니다.
    var _speed = 0.04; // 페이드 속도.
    if (command_string_switch == true)
    {
        if (command_string_time == command_string_time_max) // 사운드 재생.
        {
            if (audio_is_playing(Sou_Warning_Message) == false)
            {
                audio_play_sound(Sou_Warning_Message, 1000, false);
            }
        }
        
        if (command_string_time &gt; 0)
        {
            if (command_string_alpha &lt; 1)
            {
                command_string_alpha += (_speed * 2);
            }
            else 
            {
                command_string_alpha = 1;
                command_string_time --;
            }
        }
        else
        {
            if (command_string_alpha &gt; 0)
            {
                command_string_alpha -= _speed;
            }
            else
            {
                command_string_time = command_string_time_max;
                command_string_switch = false;
            }
        }
        var _font = font_waring_alarm; draw_set_font(_font);
        var _font = font_get_texture(_font);
        var _texel_width = texture_get_texel_width(_font);
        var _texel_height = texture_get_texel_height(_font);
        var _texture = shader_get_uniform(shader_set_font, "v_TexturePixelSize");
        
        shader_set(shader_set_font);        
        shader_enable_corner_id(true);
        
        shader_set_uniform_f(_texture, _texel_width, _texel_height);
        
        draw_set_halign(fa_center);
        draw_set_valign(fa_top);
        draw_set_colour(c_white);
        draw_set_alpha(command_string_alpha);
        
        var _command_string = command_string;
        draw_text(display_get_gui_width() / 2, command_gui_y, _command_string);
        draw_set_alpha(1);
        
        shader_reset();    
        shader_enable_corner_id(false);
    }
    
    // 화면 확대 축소 GUI.
    var _width = 5; // *2.
    var _size = (48 / 2);
    draw_set_alpha(gui_alpha);
    draw_set_colour(c_black);
    draw_rectangle(screen_zoom_x - _width, screen_zoom_y - _size, screen_zoom_x + _width, screen_zoom_y + screen_zoom_height + _size, false);
    draw_set_colour(c_white);
    draw_rectangle(screen_zoom_x - _width, screen_zoom_y - _size, screen_zoom_x + _width, screen_zoom_y + screen_zoom_height + _size, true);
    
    var _m = 0, _n = 1;
    var _x = screen_zoom_bar_x;
    var _y = screen_zoom_bar_y;
    draw_set_colour(c_dkgray);
    draw_rectangle(_x - _size, _y - _size, _x + _size, _y + _size, false);
    draw_set_colour(c_white);
    draw_rectangle(_x - _size, _y - _size, _x + _size, _y + _size, true);
    draw_set_alpha(1);
    
    if (global.lock_step == false)
    &amp;&amp; ((_x - _size) &lt; mx_gui[_m]) &amp;&amp; ((_y - _size) &lt; my_gui[_m])
    &amp;&amp; (mx_gui[_m] &lt; (_x + _size)) &amp;&amp; (my_gui[_m] &lt; (_y + _size))
    {
        if (mbp_L[_m] == true)
        {
            screen_zoom_pressed = true;
            screen_zoom_pressed_y = my_gui[_m];
        }
    }
    
    if (screen_zoom_pressed == true)
    {
        if (mbc_L[_m] == true)
        {
            var _s = screen_zoom_pressed_y - my_gui[_m];
            screen_zoom_bar_y -= _s;
            screen_zoom_pressed_y -= _s;
            
            if (screen_zoom_bar_y &lt; screen_zoom_y)
            {
                screen_zoom_bar_y = screen_zoom_y;
            }
            else if (screen_zoom_bar_y &gt; screen_zoom_y + screen_zoom_height)
            {
                screen_zoom_bar_y = screen_zoom_y + screen_zoom_height;
            }
        }
        if (mbr_L[_m] == true)
        {
            screen_zoom_pressed = false;
        }
    }

    var _y_max = (screen_zoom_y + (screen_zoom_height / 2)) - screen_zoom_y;
    var _y = (screen_zoom_y - screen_zoom_bar_y);
    cont_dis = 1 + (_y / _y_max);
}

if (global.lock_step == true)
{
    info_switch = false;
    for(var _i = 0; _i &lt; group_max; _i ++)
    {
        group_pressed[_i] = false;
        group_camera[_i] = false;
    }
}
else
{
    info_switch = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 타일 서피스 드로우.
if (surface_exists(tile_surface) == true)
{
    draw_surface(tile_surface, 0, 0);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 선택된 건물과 유닛 표시.
if (global.draw_gui == true)
{
    var _list_size = ds_list_size(select_list);
    for(var _i = 0; _i &lt; _list_size; _i ++)
    {
        var _ins = ds_list_find_value(select_list, _i);
        if (_ins != undefined) &amp;&amp; (instance_exists(_ins) == true)
        &amp;&amp; (_ins.build != 0)
        {   
            // 목적지 드로우.
            if (global.set_team == _ins.set_team)
            {
                // 공격하는 대상이 있을 때.
                if (instance_exists(_ins.attack_target) == true)
                {
                    draw_set_colour(c_orange);
                    draw_line_width(_ins.x, _ins.y, _ins.move_x, _ins.move_y, 2);
                    draw_set_colour(c_red);
                    draw_line_width(_ins.x, _ins.y, _ins.attack_target.x, _ins.attack_target.y, 2);
                }
                else if (_ins.action == 10)
                &amp;&amp; (instance_exists(_ins.attack_move) == true)
                {
                    draw_set_colour(c_lime);
                    draw_line_width(_ins.x, _ins.y, _ins.attack_move.x, _ins.attack_move.y, 2);
                }
                else // 공격하는 대상이 없을 때.
                {
                    // 목적지 드로우.
                    draw_set_colour(c_lime);
                    switch(_ins.action)
                    {
                        case 0: draw_set_colour(c_white); break;
                        case 2: case 3: draw_set_colour(c_orange); break;
                        case 8: case 9: draw_set_colour(c_yellow); break;
                    }
                    var _parent = object_get_parent(_ins.object_index);
                    if (_parent == Obj_Building)
                    {
                        draw_set_colour(c_lime); if (_ins.produce == false) {break;}
                        var _pos = instance_position(_ins.move_x, _ins.move_y, Obj_Sight);
                        if (instance_exists(_pos) == true)
                        {
                            if (Obj_101 == _pos.object_index)
                            || (Obj_Ore == _pos.object_index)
                            {draw_set_colour(c_yellow);}
                        }
                    }
                    draw_line_width(_ins.x, _ins.y, _ins.move_x, _ins.move_y, 2);
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 치트 사용

global.get_resource_value[global.set_player, 3] -= 1000;
global.get_resource_value[global.set_player, 1] -= 20000;
global.get_resource_value[global.set_player, 0] -= 20000;

command_string_switch = true;
command_string = "CHEAT ON";
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>0</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
