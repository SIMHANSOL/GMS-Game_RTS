<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 설정.
set_id = -1; // 지정된 고유 값.
set_player = -1; // 지정된 플레이어.
set_team = -1; // 지정된 팀.
set_colour = -1; // 지정된 색.

// CSV 값.
var _plus = 0;
number = return_csv_number(object_index);
name = string(global.sight_table[number, _plus]); _plus ++; // 이름.
hp_max = real(global.sight_table[number, _plus]); _plus ++;
mp_max = real(global.sight_table[number, _plus]); _plus ++;
attack_type = real(global.sight_table[number, _plus]); _plus ++; // 공격 타입. -1은 공격이 없다.
attack_value = real(global.sight_table[number, _plus]); _plus ++; // 공격력.
attack_up = real(global.sight_table[number, _plus]); _plus ++; // 공격력 업그레이드 증가 수치.
attack_speed = (real(global.sight_table[number, _plus]) * room_speed); _plus ++; // 공격 속도.
attack_range = real(global.sight_table[number, _plus]); _plus ++; // 공격 사거리 6칸.
attack_angle = real(global.sight_table[number, _plus]); _plus ++;
attack_sense_range = real(global.sight_table[number, _plus]); _plus ++; // 공격 대상을 자동으로 인지하는 범위.
attack_air = real(global.sight_table[number, _plus]); _plus ++;
attack_image = real(global.sight_table[number, _plus]); _plus ++; // 공격이 나가는 이미지.
attack_bullet = asset_get_index(string(global.sight_table[number, _plus])); _plus ++;
defense_type = real(global.sight_table[number, _plus]); _plus ++; // 방어 타입.
defense_value = real(global.sight_table[number, _plus]); _plus ++; // 방어력.
defense_up = real(global.sight_table[number, _plus]); _plus ++; // 방어력 업그레이드 증가 수치.
sight_range = real(global.sight_table[number, _plus]); _plus ++; // 시야 6칸 (기본).
move_speed = ((real(global.sight_table[number, _plus]) * global.target_fps) / room_speed); _plus ++; // 이동 속도.
angle_speed = ((real(global.sight_table[number, _plus]) * global.target_fps) / room_speed); _plus ++;  // 회전 속도.
state = real(global.sight_table[number, _plus]); _plus ++; // 0: 생물, 1: 기계.
air = real(global.sight_table[number, _plus]); _plus ++; // 유닛이 지상 유닛인지 공중 유닛인지. (0: 지상, 1: 공중)
priority = real(global.sight_table[number, _plus]); _plus ++; // 명령창 우선도.
supply = real(global.sight_table[number, _plus]); _plus ++; // 최대 인구 증가치.
gui_sprite = real(global.sight_table[number, _plus]); _plus ++; // 스프라이트 번호.
build_resource[0] = real(global.sight_table[number, _plus]); _plus ++; // 필요 광석.
build_resource[1] = real(global.sight_table[number, _plus]); _plus ++; // 필요 원유.
build_resource[2] = real(global.sight_table[number, _plus]); _plus ++; // 필요 인구.
build_time_max = real(global.sight_table[number, _plus]); _plus ++; // 건설에 걸리는 시간.
slot = real(global.sight_table[number, _plus]); _plus ++; // 탑승물 자리 차지량.

// 설정 값.
mp_recovery_value = 1;
mp_recovery_alarm = (1 * room_speed);
draw_hp_bar_y = 24; // 얼마나 위로 올릴지 정합니다.
hit_part = Obj_Part_System.blood; // 피격 파티클.
hit_part_number = 5; // 피격 파티클 숫자.

// 기본 값.
hp = hp_max; // 체력.
mp = mp_max; // 마나.
mp_recovery_time = mp_recovery_alarm; // 마나 회복 타임 변수.
action = 0; // 행동중인 상태. 0: 정지, 1: 이동, 2: 공격.
move_x = x;
move_y = y;
moving = true; // 패스를 만들어야 되는지 확인.
path = path_add(); // 패스 값.
attack_target = noone; // 불렛에 넘겨줄 대상 오브젝트.
attack_move = noone; // 공격중 이동할 대상.
attack_time = 0; // 공격 시간 값.
attack_first = false; // 첫 포커스 대상인지 확인하는 변수.
attack_focus = noone; // 첫 포커스 대상.
draw_hp_bar_width = (bbox_right - bbox_left) / 2; // 체력 바 가로 사이즈.
build = 2; // 건설 상태 (0: 건설 전, 1: 건설 중, 2: 건설 완료).
set_floor = 0; // 현재 층을 나타냄.
slot_number = 0; // 탑승물의 현재 적재량.
hit = false; // 맞았는지.
hit_caster = noone; // 때린 가해자.
hit_floor = 0; // 가해자 층.
hit_alarm = 0; // hit을 종료할 알람 타임.
hit_alarm_max = (1 * room_speed); // 얼마만큼의 시간동안 맞았는지의 알람을 울릴지 결정.
image_speed_value = ((0.4 * global.target_fps) / room_speed); // 애니메이션 속도.
mask_index = sprite_index; // 충돌 범위.
destroy = noone; // 파괴될 때 잠시동안 파괴 오브젝트를 임시로 담을 변수. 

// 인공지능 관련 스크립트.
ai_obj = noone;
ai_number_check = false;

// 런 AI 스크립트.
run_step_alarm_max = ceil(room_speed / 4);
run_step_alarm = run_step_alarm_max;

// GUI에 명령을 뿌릴 변수입니다. []은 순서입니다.
get_command[0] = -1; // 정지.
get_command[1] = -1; // 홀드.
get_command[2] = -1; // 이동.
get_command[3] = -1; // 공격.
get_command[4] = -1; // 없음.
get_command[5] = -1; // 없음.
get_command[6] = -1; // 없음.
get_command[7] = -1; // 없음.

// 시야에 들어와 있는지 확인하는 변수입니다. (특히 미니맵 드로우할 때)
f_x = floor(x / Obj_Game_System.fog_scale);
f_y = floor(y / Obj_Game_System.fog_scale);

// 쉐이더 시스템.
colour_to_find = shader_get_uniform(shader_set_colour, "f_Colour1");
colour_to_set = shader_get_uniform(shader_set_colour, "f_Colour2");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy.
var _index = ds_list_find_index(global.list_id, set_id);
ds_list_delete(global.list_id, _index);
ds_list_delete(global.list_id, _index);

if (global.set_team == set_team)
{
    var _index = ds_list_find_index(global.list_sight, self.id);
    ds_list_delete(global.list_sight, _index);
}

if (path_exists(path) == true) {path_delete(path);}

if (instance_exists(ai_obj) == true)
{
    var _string = "_" + object_get_name(object_index);
    var _value = variable_instance_get(ai_obj, _string);
    if (_value != undefined) {variable_instance_set(ai_obj, _string, --_value);}
}

if (build != 0)
{
    destroy = instance_create(x, y, Obj_Destroy_Anim);
    destroy.set_colour = set_colour;
    destroy.sprite[0] = sprite_index;
    destroy.sprite_angle[0] = image_angle;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 시야에 들어와 있는지 연산하는 변수입니다.
x = min(room_width, max(x, 0));
y = min(room_height, max(y, 0));

f_x = min(max(floor(x / Obj_Game_System.fog_scale), 0), Obj_Game_System.fog_room_width);
f_y = min(max(floor(y / Obj_Game_System.fog_scale), 0), Obj_Game_System.fog_room_height);

if (build != 0) {depth = (room_height - y) - (air * 10000);}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 주요 연산 이전에 하는 일들.
if (global.lock_step == false)
{
    if (hp &lt;= 0) // 체력이 없을 시 제거.
    {
        if (instance_exists(Obj_Game_System) == true)
        {
            var _index = ds_list_find_index(Obj_Game_System.select_list, self.id);
            if (_index != -1)
            {
                ds_list_delete(Obj_Game_System.select_list, _index);
            }
            
            if (global.set_team == set_team)
            {
                ds_grid_set_disk(Obj_Game_System.fog_grid, 
                min(max(round(x / Obj_Game_System.fog_scale), 0), Obj_Game_System.fog_room_width), 
                min(max(round(y / Obj_Game_System.fog_scale), 0), Obj_Game_System.fog_room_height), 
                sight_range / Obj_Game_System.fog_scale, 1);
            }
        }
        instance_destroy();
    }
    
    if (image_angle != direction) // 스프라이트 방향 회전.
    {
        var _rotate = abs(direction - image_angle);
        var _rev = 1; if (_rotate &gt; 180) {_rev = -1;}
        var _spd = min(abs(360 - (direction - image_angle)), _rotate, abs(360 + (direction - image_angle))) / ((angle_speed * room_speed) / global.target_fps);
        image_angle += (sign(direction - image_angle) * _spd) * _rev;
    
        if(image_angle &gt; 359) {image_angle = 0;}
        if(image_angle &lt; 0) {image_angle = 359;}
    }
    
    if (hit_alarm &lt;= 0) // 피격 판정 제어.
    {
        hit = false;
        hit_floor = set_floor;
        hit_caster = noone;
    }
    else 
    {
        hit_alarm --;
    }
    
    if (ai_number_check == false) // 인공지능 전용.
    &amp;&amp; (instance_exists(ai_obj) == true)
    {
        var _string = "_" + object_get_name(object_index);
        var _value = variable_instance_get(ai_obj, _string);
        if (_value != undefined) {variable_instance_set(ai_obj, _string, ++_value);}
        ai_number_check = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 층 설정.
var _place = instance_position(x, y, Obj_Floor);
if (instance_exists(_place) == true)
{set_floor = _place.set_floor;} else {set_floor = 0;}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 마나 회복 설정.
if (mp_max &gt; 0) // 마나를 사용하는 경우.
{
    if (mp_recovery_time &lt;= 0)
    {
        if ((mp + mp_recovery_value) &lt;= mp_max)
        {mp += mp_recovery_value;} else {mp = mp_max;}
        mp_recovery_time = mp_recovery_alarm;
    }
    else
    {
        mp_recovery_time --;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 공격.
var _x = x + lengthdir_x(30, image_angle - 15);
var _y = y + lengthdir_y(30, image_angle - 15);
var _bullet = instance_create(_x, _y, attack_bullet);
_bullet.caster = self.id;
_bullet.target = attack_target;
_bullet.value = attack_value;
_bullet.type = attack_type;
attack_time = attack_speed;

part_particles_create(Obj_Part_System.system_part, _x, _y, Obj_Part_System.yellow_smoke, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DEBUG.

//draw_set_font(font_resource);
//draw_text(x + 40, y + 30, slot_number)
//draw_text(x + 20, y + 50, slot)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
