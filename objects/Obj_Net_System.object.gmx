<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1000000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 필요한 시스템 변수를 선언합니다.

// 프레임 동기화.
global.frame_number = 0; // 몇 회인지 나타내는 수.
global.frame_rate = (room_speed / 30); // 프레임 언제 보낼지 설정.
global.frame = 0; // 실제 진행된 프레임.
global.lock_step = false;
global.prev_delta_time = 0;

global.current_player = ds_list_size(global.list_player);
for(var _i = 0; _i &lt; global.max_player; _i ++)
{
    global.data_check[_i, 0] = false;
    global.data_check[_i, 1] = false;
    global.data_check[_i, 2] = false;
}
global.data_number = 0;
global.return_data_number = 0; // 클라이언트 전용.
global.send_client[0] = false; // 전송했는지 확인.
global.send_client[1] = false;
global.send_client[2] = false;

// 명령 총합을 담을 버퍼입니다.
global.game_replay = buffer_create(1, buffer_grow, 1);

// 명령 커맨드를 담을 버퍼입니다.
global.action_command = buffer_create(1, buffer_grow, 1);
buffer_seek(global.action_command, buffer_seek_start, 0);
buffer_write(global.action_command, buffer_u8, 100); // 버퍼 시작을 알림.
buffer_write(global.action_command, buffer_u16, global.data_number); // 버퍼 넘버링을 알림.

// 버퍼 선언.
global.buffer[0] = buffer_create(1, buffer_grow, 1);
buffer_write(global.buffer[0], buffer_u8, 100); // 버퍼 시작을 알림.
global.buffer[1] = buffer_create(1, buffer_grow, 1);
buffer_write(global.buffer[1], buffer_u8, 100); // 버퍼 시작을 알림.
global.buffer[2] = buffer_create(1, buffer_grow, 1);
buffer_write(global.buffer[2], buffer_u8, 100); // 버퍼 시작을 알림.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 멀티 플레이 (잘못됨)
// LOCK STEP 원칙!
// 1. 각 지정된 프레임마다 패킷을 서버에게 전송한다.
// 2. 서버는 클라이언트에게 받은 패킷과 자신의 패킷을 함께 버퍼 0으로 저장하고 각 클라이언트에게 돌린다.
// 3. 이 때 게임은 락 상태여야한다.
// 4. 1, 2를 반복하여 버퍼 2가 찼을 경우 락을 중지하고 버퍼 0을 실행한다.

// 잘못된 이유
// 1. 클라이언트는 받자마자 시행하기 때문에 몇 프레임인지 구분하기 힘들다
// 2. [동일한 프레임에 시행되질 않아] 락을 어느 때 걸어야 할지 모른다
// 3. 다음에 만들 땐 각자 버퍼 스택같은 곳에 0, 1, 2, 3, 4, 쌓고 다 사용한 버퍼는 딜리트하자
// 4. 2턴마다 주고 받으니 렉은 없지만 확실히 반응 문제 발생
// 이거 때문에 며칠 까먹지말자 하루면 만드니까 조급해 하지 말자 일단 싱글부터 하자!


// 네트워크 프레임 동기화 구성.
var _rate = (global.frame_number * global.frame_rate); // 지정 프레임.

// 지정된 프레임에 클라이언트는 패킷을 서버로 전송한다.
if (global.frame &gt;= _rate)
{
    buffer_write(global.action_command, buffer_u16, 255); // 버퍼 끝을 알림.
    
    if (global.have_server == true) // 호스트일 때.
    {
        buffer_seek(global.action_command, buffer_seek_start, 0);
        var _temp = buffer_read(global.action_command, buffer_u8);
        var _data_number = buffer_read(global.action_command, buffer_u16);
        while(true)
        {
            var _action = buffer_read(global.action_command, buffer_u16);
            if (_action == 255) {break;} // 버퍼의 끝일 경우.
            
            buffer_write(global.buffer[_data_number], buffer_u16, _action);
            buffer_write(global.buffer[_data_number], buffer_u16, buffer_read(global.action_command, buffer_u16));
            buffer_write(global.buffer[_data_number], buffer_s16, buffer_read(global.action_command, buffer_s16));
            buffer_write(global.buffer[_data_number], buffer_s16, buffer_read(global.action_command, buffer_s16));
        }
        global.data_check[0, _data_number] = true;
    }
    else // 클라이언트일 때.
    {
        network_send_packet(global.socket, global.action_command, buffer_get_size(global.action_command));
    }
    
    global.frame_number ++;
    if (global.data_number &lt; 2) {global.data_number ++;}
    
    
    // 명령 패킷 전송 후 명령 목록 삭제.
    buffer_seek(global.action_command, buffer_seek_start, 0);
    buffer_write(global.action_command, buffer_u8, 100); // 버퍼 시작을 알림.
    buffer_write(global.action_command, buffer_u16, global.data_number); // 버퍼 넘버링을 알림.
}

// 패킷이 마지막이면 마감 처리 후 전송.
if (global.have_server == true)
{
    for (var _j = 0; _j &lt; 3; _j ++)
    {
        if (global.send_client[_j] == false)
        {
            var _check = 0;
            for (var _i = 0; _i &lt; global.max_player; _i ++)
            {
                if (global.data_check[_i, _j] == true) {_check ++;}
            }
            
            if (global.current_player &lt;= _check)
            {
                buffer_write(global.buffer[_j], buffer_u16, 255); // 버퍼 끝을 알림.
                
                // 해당 인원수에 맞게 패킷이 잘 왔는지 확인하고 클라이언트에게 패킷을 전송합니다.
                for(var _k = 0; _k &lt; ds_list_size(global.list_player); _k ++)
                {
                    // 플레이어들의 고유 소켓 ID 불러오기.
                    var _socket = ds_list_find_value(global.list_player, _k);
                    
                    // 클라이언트에게 해당 시간에 다음 프레임으로 진행하면 된다고 메세지 전송.
                    network_send_packet(_socket, global.buffer[_j], buffer_get_size(global.buffer[_j]));
                }
                if (_j != 2) {global.send_client[_j] = true;}
            }
        }
    }
}    

// 시행할 2번 패킷이 다왔는지 확인합니다.
var _check = 0; 
for (var _i = 0; _i &lt; global.max_player; _i ++)
{
    if (global.data_check[_i, 2] == true) {_check ++;}
}

// 패킷 처리. (서버는 따로 인원 수 체크하고 시행)
if ((global.have_server == true) &amp;&amp; (global.current_player &lt;= _check))
|| ((global.return_data_number + 1) &gt;= 3)
{
    buffer_seek(global.buffer[0], buffer_seek_start, 0); // 시작.
    buffer_seek(global.buffer[1], buffer_seek_start, 0);
    buffer_seek(global.buffer[2], buffer_seek_start, 0);
    var _temp = buffer_read(global.buffer[0], buffer_u8);
    while(true)
    {
        var _action = buffer_read(global.buffer[0], buffer_u16);
        if (_action == 255) {break;}
        
        var _ins_get = buffer_read(global.buffer[0], buffer_u16);
        var _ins_index = ds_list_find_index(global.list_id, _ins_get);
        var _ins = ds_list_find_value(global.list_id, _ins_index + 1);
        
        var _mx = buffer_read(global.buffer[0], buffer_s16);
        var _my = buffer_read(global.buffer[0], buffer_s16);
        if (instance_exists(_ins) == true)
        {
            _ins.action = _action;
            _ins.move_x = _mx;
            _ins.move_y = _my;
            _ins.moving = true;
            _ins.attack_first = false;
            _ins.attack_focus = noone;
        }
    }
    
    buffer_delete(global.buffer[0]);
    global.buffer[0] = buffer_create(1, buffer_grow, 1);
    buffer_copy(global.buffer[1], 0, buffer_get_size(global.buffer[1]), global.buffer[0], 0);
    
    buffer_delete(global.buffer[1]);
    global.buffer[1] = buffer_create(1, buffer_grow, 1);
    buffer_copy(global.buffer[2], 0, buffer_get_size(global.buffer[2]), global.buffer[1], 0);
    
    buffer_delete(global.buffer[2]);
    global.buffer[2] = buffer_create(1, buffer_grow, 1);
    buffer_write(global.buffer[2], buffer_u8, 100); // 버퍼 시작을 알림.
    
    for (var _i = 0; _i &lt; global.max_player; _i ++)
    {
        global.data_check[_i, 2] = false;
    }
    
    global.return_data_number --;
} 

if (global.lock_step == false) {global.frame ++;}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 멀티 플레이 (잘못됨)
var _id = ds_map_find_value(async_load, "id"); // 이벤트가 발생한 ID.
var _socket = ds_map_find_value(async_load, "socket"); // 소켓 고유 번호.

if(global.have_server == true) // 서버 방장일 경우.
{
    switch(ds_map_find_value(async_load, "type"))
    {
        case network_type_data:
        {
            var _read_buffer = ds_map_find_value(async_load, "buffer");
            switch(buffer_read(_read_buffer, buffer_u8)) // 데이터 역할 구별.
            {
                // 클라이언트에게서 패킷이 오는 경우.
                case 100:
                {
                    var _data_number = buffer_read(_read_buffer, buffer_u16);
                    while(true)
                    {
                        var _action = buffer_read(_read_buffer, buffer_u16);
                        if (_action == 255) {break;} // 버퍼의 끝일 경우.
                        
                        buffer_write(global.buffer[_data_number], buffer_u16, _action);
                        buffer_write(global.buffer[_data_number], buffer_u16, buffer_read(_read_buffer, buffer_u16));
                        buffer_write(global.buffer[_data_number], buffer_s16, buffer_read(_read_buffer, buffer_s16));
                        buffer_write(global.buffer[_data_number], buffer_s16, buffer_read(_read_buffer, buffer_s16));
                    }
                    
                    // 패킷을 작성했음을 알림.
                    global.data_check[_id, _data_number] = true;
                }
                break;
            }
        }
        break;
    }
}
else
{
    switch(ds_map_find_value(async_load, "type"))
    {
        case network_type_data:
        {
            var _read_buffer = ds_map_find_value(async_load, "buffer");
            switch(buffer_read(_read_buffer, buffer_u8)) // 데이터 역할 구별.
            {
                // 버퍼 받아오기.
                case 100:
                {
                    buffer_seek(global.buffer[0], buffer_seek_start, 0); // 시작.
                    buffer_seek(global.buffer[1], buffer_seek_start, 0);
                    buffer_seek(global.buffer[2], buffer_seek_start, 0);
                    buffer_seek(_read_buffer, buffer_seek_start, 0);
                    
                    buffer_copy(_read_buffer, 0, buffer_get_size(_read_buffer), global.buffer[global.return_data_number], 0);
                    
                    if (global.return_data_number &lt; 2) {global.return_data_number ++;}
                }
                break;
            }
            break;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 디버그용 화면 출력.
/*
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_font(font_gui_command);
draw_set_color(c_white);

draw_text(720, 20, global.frame);
draw_text(720, 40, global.frame_number);
draw_text(720, 60, global.data_number);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
